[PATCH] Jorge’s release 1.0.2 over 1.0.1

---
 AUTHORS                               |   3 +-
 configure.ac                          |  23 +-
 gamedata/Makefile.am                  |   2 +-
 gamedata/gfx/blacktooth/Makefile.am   |   2 +-
 gamedata/gfx/byblos/Makefile.am       |   2 +-
 gamedata/gfx/egyptus/Makefile.am      |   2 +-
 gamedata/gfx/gui/Makefile.am          |   2 +-
 gamedata/gfx/item/Makefile.am         |   2 +-
 gamedata/gfx/jail/Makefile.am         |   2 +-
 gamedata/gfx/market/Makefile.am       |   2 +-
 gamedata/gfx/moonbase/Makefile.am     |   4 +-
 gamedata/gfx/penitentiary/Makefile.am |   2 +-
 gamedata/gfx/safari/Makefile.am       |   2 +-
 gamedata/map/Makefile.am              |   4 +-
 gamedata/map/blacktooth/Makefile.am   |   2 +-
 gamedata/map/byblos/Makefile.am       |   2 +-
 gamedata/map/egyptus/Makefile.am      |   2 +-
 gamedata/map/moonbase/Makefile.am     |   2 +-
 gamedata/map/penitentiary/Makefile.am |   2 +-
 gamedata/map/safari/Makefile.am       |   2 +-
 gamedata/music/Makefile.am            |   2 +-
 gamedata/savegame/Makefile.am         |   2 +-
 gamedata/sound/Makefile.am            |   2 +-
 gamedata/text/Makefile.am             |   2 +-
 src/BonusManager.cpp                  |  33 +-
 src/BonusManager.hpp                  |   6 +-
 src/GameFileManager.cpp               | 371 ++++++------
 src/GameFileManager.hpp               |   4 +-
 src/GameManager.hpp                   |   1 -
 src/Ism.cpp                           |  31 +-
 src/Isomot.cpp                        |   7 +-
 src/Isomot.hpp                        |   4 +-
 src/ItemDataManager.cpp               | 705 +++++++++++-----------
 src/ItemDataManager.hpp               | 131 +++--
 src/Makefile.am                       |  26 +-
 src/MapManager.cpp                    | 663 ++++++++++-----------
 src/MapManager.hpp                    |  43 +-
 src/Room.hpp                          |   2 +-
 src/RoomBuilder.cpp                   | 815 ++++++++++++++------------
 src/RoomBuilder.hpp                   | 199 ++++---
 src/SoundManager.cpp                  | 546 +++++++++--------
 src/SoundManager.hpp                  |  10 +-
 src/actions/CreateFileGameMenu.cpp    |  37 +-
 src/actions/CreateFileGameMenu.hpp    |   2 +-
 src/actions/CreateLanguageMenu.cpp    | 156 +++--
 src/actions/CreateLanguageMenu.hpp    |  68 +--
 src/gui/ConfigurationManager.cpp      | 123 ++--
 src/gui/ConfigurationManager.hpp      | 174 +++---
 src/gui/GuiManager.cpp                |   4 +-
 src/gui/LanguageManager.cpp           | 115 ++--
 src/gui/LanguageManager.hpp           | 147 +++--
 src/main.cpp                          |   1 +
 52 files changed, 2264 insertions(+), 2234 deletions(-)
 delete src/csxml/
 delete src/xsd/

diff --git a/AUTHORS b/AUTHORS
index 1b2335e..845fe26 100644
--- a/AUTHORS
+++ b/AUTHORS
@@ -1,5 +1,4 @@
-Jorge Rodríguez Santos <jorge@helmantika.org>
+Jorge Rodríguez Santos <jorge@helmantika.com>
 
 This software includes parts of
 alogg, copyright 2003 Vincent Penquerc'h
-CodeSynthesis XSD, copyright 2005-2009 Code Synthesis Tools CC
\ No newline at end of file
diff --git a/configure.ac b/configure.ac
index 5bc2003..059bf5d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,8 +1,10 @@
 # Process this file with autoconf to produce a configure script.
 
-AC_PREREQ([2.63])
-AC_INIT(headoverheels, 1.0, jorge@helmantika.org)
-AM_INIT_AUTOMAKE(headoverheels, 1.0)
+AC_INIT([headoverheels],[1.0.2])
+AM_INIT_AUTOMAKE([subdir-objects])
+
+CFLAGS=
+CXXFLAGS=
 
 # Checks for programs.
 AC_PROG_CC
@@ -11,14 +13,17 @@ AC_PROG_CXX
 # Checks for libraries.
 
 # Checks for header files.
-AC_CHECK_HEADERS(allegro.h,, [AC_MSG_ERROR(allegro headers not found! Please, install allegro-devel)])
-AC_CHECK_HEADERS(vorbis/codec.h vorbis/vorbisenc.h vorbis/vorbisfile.h,, [AC_MSG_ERROR(vorbis headers not found! Please, install vorbis-devel)])
-AC_CHECK_HEADERS(ogg/ogg.h,, [AC_MSG_ERROR(ogg headers not found! Please, install ogg-devel)])
-AC_CHECK_HEADERS(xercesc/util/XercesVersion.hpp,, [AC_MSG_ERROR(xerces-c headers not found! Please, install xerces-c-devel)])
-AC_CHECK_HEADERS(pthread.h,, [AC_MSG_ERROR(pthread headers not found! Please, install glibc-devel)])
+AC_CHECK_HEADERS([allegro.h], [], [AC_MSG_ERROR(allegro headers not found! Please, install liballegro4-dev)])
+AC_CHECK_HEADERS([vorbis/codec.h vorbis/vorbisenc.h vorbis/vorbisfile.h], [], [AC_MSG_ERROR(vorbis headers not found! Please, install libvorbis-dev)])
+AC_CHECK_HEADERS([ogg/ogg.h], [], [AC_MSG_ERROR(ogg headers not found! Please, install libogg-dev)])
+AC_LANG_PUSH([C++])
+AC_CHECK_HEADER([boost/property_tree/xml_parser.hpp], [], [AC_MSG_ERROR(boost headers not found! Please, install libboost1.71-dev)])
+AC_LANG_POP([C++])
+AC_CHECK_HEADERS([pthread.h], [], [AC_MSG_ERROR(pthread headers not found! Please, install libpthread-stubs0-dev)])
 
 # Checks for typedefs, structures, and compiler characteristics.
 
 # Checks for library functions.
 
-AC_OUTPUT(Makefile src/Makefile gamedata/Makefile  gamedata/gfx/Makefile gamedata/gfx/blacktooth/Makefile gamedata/gfx/byblos/Makefile gamedata/gfx/egyptus/Makefile gamedata/gfx/gui/Makefile gamedata/gfx/item/Makefile gamedata/gfx/jail/Makefile gamedata/gfx/market/Makefile gamedata/gfx/moonbase/Makefile gamedata/gfx/penitentiary/Makefile gamedata/gfx/safari/Makefile gamedata/map/Makefile gamedata/map/blacktooth/Makefile gamedata/map/byblos/Makefile gamedata/map/egyptus/Makefile gamedata/map/moonbase/Makefile gamedata/map/penitentiary/Makefile gamedata/map/safari/Makefile gamedata/music/Makefile gamedata/savegame/Makefile gamedata/sound/Makefile gamedata/text/Makefile)
+AC_CONFIG_FILES([Makefile src/Makefile gamedata/Makefile  gamedata/gfx/Makefile gamedata/gfx/blacktooth/Makefile gamedata/gfx/byblos/Makefile gamedata/gfx/egyptus/Makefile gamedata/gfx/gui/Makefile gamedata/gfx/item/Makefile gamedata/gfx/jail/Makefile gamedata/gfx/market/Makefile gamedata/gfx/moonbase/Makefile gamedata/gfx/penitentiary/Makefile gamedata/gfx/safari/Makefile gamedata/map/Makefile gamedata/map/blacktooth/Makefile gamedata/map/byblos/Makefile gamedata/map/egyptus/Makefile gamedata/map/moonbase/Makefile gamedata/map/penitentiary/Makefile gamedata/map/safari/Makefile gamedata/music/Makefile gamedata/savegame/Makefile gamedata/sound/Makefile gamedata/text/Makefile])
+AC_OUTPUT
diff --git a/gamedata/Makefile.am b/gamedata/Makefile.am
index c3450ed..42f398a 100644
--- a/gamedata/Makefile.am
+++ b/gamedata/Makefile.am
@@ -1,4 +1,4 @@
-gamedatadir = $(datadir)/@PACKAGE@
+gamedatadir = $(datadir)/@PACKAGE@/gamedata
 gamedata_DATA = configuration.xml \
 		configuration.xsd \
 		items.xml \
diff --git a/gamedata/gfx/blacktooth/Makefile.am b/gamedata/gfx/blacktooth/Makefile.am
index fdf1f5e..2d0292b 100644
--- a/gamedata/gfx/blacktooth/Makefile.am
+++ b/gamedata/gfx/blacktooth/Makefile.am
@@ -1,4 +1,4 @@
-gamedatagfxblacktoothdir = $(datadir)/@PACKAGE@/gfx/blacktooth
+gamedatagfxblacktoothdir = $(datadir)/@PACKAGE@/gamedata/gfx/blacktooth
 gamedatagfxblacktooth_DATA = blacktooth-column-capital-east.bmp \
 			    blacktooth-column-capital-north.bmp \
 			    blacktooth-column-capital-south.bmp \
diff --git a/gamedata/gfx/byblos/Makefile.am b/gamedata/gfx/byblos/Makefile.am
index 4236c4f..c9dcd99 100644
--- a/gamedata/gfx/byblos/Makefile.am
+++ b/gamedata/gfx/byblos/Makefile.am
@@ -1,4 +1,4 @@
-gamedatagfxbyblosdir = $(datadir)/@PACKAGE@/gfx/byblos
+gamedatagfxbyblosdir = $(datadir)/@PACKAGE@/gamedata/gfx/byblos
 gamedatagfxbyblos_DATA = byblos-column-capital-east.bmp \
 			byblos-column-capital-north.bmp \
 			byblos-column-capital-south.bmp \
diff --git a/gamedata/gfx/egyptus/Makefile.am b/gamedata/gfx/egyptus/Makefile.am
index de4c85d..c6c9e5d 100644
--- a/gamedata/gfx/egyptus/Makefile.am
+++ b/gamedata/gfx/egyptus/Makefile.am
@@ -1,4 +1,4 @@
-gamedatagfxegyptusdir = $(datadir)/@PACKAGE@/gfx/egyptus
+gamedatagfxegyptusdir = $(datadir)/@PACKAGE@/gamedata/gfx/egyptus
 gamedatagfxegyptus_DATA = egyptus-column-capital-east.bmp \
 			  egyptus-column-capital-north.bmp \
 			  egyptus-column-capital-south.bmp \
diff --git a/gamedata/gfx/gui/Makefile.am b/gamedata/gfx/gui/Makefile.am
index 7285457..f3fe285 100644
--- a/gamedata/gfx/gui/Makefile.am
+++ b/gamedata/gfx/gui/Makefile.am
@@ -1,4 +1,4 @@
-gamedatagfxguidir = $(datadir)/@PACKAGE@/gfx/gui
+gamedatagfxguidir = $(datadir)/@PACKAGE@/gamedata/gfx/gui
 gamedatagfxgui_DATA = background.bmp \
 		      blacktooth.bmp \
 		      blacktooth-frame.bmp \
diff --git a/gamedata/gfx/item/Makefile.am b/gamedata/gfx/item/Makefile.am
index d615e6e..54f7bf0 100644
--- a/gamedata/gfx/item/Makefile.am
+++ b/gamedata/gfx/item/Makefile.am
@@ -1,4 +1,4 @@
-gamedatagfxitemdir = $(datadir)/@PACKAGE@/gfx/item
+gamedatagfxitemdir = $(datadir)/@PACKAGE@/gamedata/gfx/item
 gamedatagfxitem_DATA = ball.bmp \
 		      ball-shadows.bmp \
 		      bars.bmp \
diff --git a/gamedata/gfx/jail/Makefile.am b/gamedata/gfx/jail/Makefile.am
index fcce2ad..d5c6124 100644
--- a/gamedata/gfx/jail/Makefile.am
+++ b/gamedata/gfx/jail/Makefile.am
@@ -1,4 +1,4 @@
-gamedatagfxjaildir = $(datadir)/@PACKAGE@/gfx/jail
+gamedatagfxjaildir = $(datadir)/@PACKAGE@/gamedata/gfx/jail
 gamedatagfxjail_DATA = jail-column-capital-east.bmp \
 		      jail-column-capital-north.bmp \
 		      jail-column-capital-south.bmp \
diff --git a/gamedata/gfx/market/Makefile.am b/gamedata/gfx/market/Makefile.am
index 6e7312d..492d7d7 100644
--- a/gamedata/gfx/market/Makefile.am
+++ b/gamedata/gfx/market/Makefile.am
@@ -1,4 +1,4 @@
-gamedatagfxmarketdir = $(datadir)/@PACKAGE@/gfx/market
+gamedatagfxmarketdir = $(datadir)/@PACKAGE@/gamedata/gfx/market
 gamedatagfxmarket_DATA = market-column-capital-east.bmp \
 			market-column-capital-north.bmp \
 			market-column-capital-south.bmp \
diff --git a/gamedata/gfx/moonbase/Makefile.am b/gamedata/gfx/moonbase/Makefile.am
index 7732d5f..ec3982a 100644
--- a/gamedata/gfx/moonbase/Makefile.am
+++ b/gamedata/gfx/moonbase/Makefile.am
@@ -1,4 +1,4 @@
-gamedatagfxmoonbasedir = $(datadir)/@PACKAGE@/gfx/moonbase
+gamedatagfxmoonbasedir = $(datadir)/@PACKAGE@/gamedata/gfx/moonbase
 gamedatagfxmoonbase_DATA = moonbase-column-capital-east.bmp \
 			  moonbase-column-capital-north.bmp \
 			  moonbase-column-capital-south.bmp \
@@ -25,4 +25,4 @@ gamedatagfxmoonbase_DATA = moonbase-column-capital-east.bmp \
 			  moonbase-wall-y-1.bmp \
 			  moonbase-wall-y-2.bmp \
 			  moonbase-wall-y-3.bmp \
-			  moonbase-wall-y-4.bmp
\ No newline at end of file
+			  moonbase-wall-y-4.bmp
diff --git a/gamedata/gfx/penitentiary/Makefile.am b/gamedata/gfx/penitentiary/Makefile.am
index 5d1ed2f..8ebdb7f 100644
--- a/gamedata/gfx/penitentiary/Makefile.am
+++ b/gamedata/gfx/penitentiary/Makefile.am
@@ -1,4 +1,4 @@
-gamedatagfxpenitentiarydir = $(datadir)/@PACKAGE@/gfx/penitentiary
+gamedatagfxpenitentiarydir = $(datadir)/@PACKAGE@/gamedata/gfx/penitentiary
 gamedatagfxpenitentiary_DATA = penitentiary-column-capital-east.bmp \
 			      penitentiary-column-capital-north.bmp \
 			      penitentiary-column-capital-south.bmp \
diff --git a/gamedata/gfx/safari/Makefile.am b/gamedata/gfx/safari/Makefile.am
index 2cd01e9..b5d363c 100644
--- a/gamedata/gfx/safari/Makefile.am
+++ b/gamedata/gfx/safari/Makefile.am
@@ -1,4 +1,4 @@
-gamedatagfxsafaridir = $(datadir)/@PACKAGE@/gfx/safari
+gamedatagfxsafaridir = $(datadir)/@PACKAGE@/gamedata/gfx/safari
 gamedatagfxsafari_DATA = safari-column-capital-east.bmp \
 			safari-column-capital-north.bmp \
 			safari-column-capital-south.bmp \
diff --git a/gamedata/map/Makefile.am b/gamedata/map/Makefile.am
index 26d511a..20c79f9 100644
--- a/gamedata/map/Makefile.am
+++ b/gamedata/map/Makefile.am
@@ -1,5 +1,5 @@
-gamedatamapdir = $(datadir)/@PACKAGE@/map
+gamedatamapdir = $(datadir)/@PACKAGE@/gamedata/map
 gamedatamap_DATA = map.xml \
 		  map.xsd
 
-SUBDIRS = blacktooth byblos egyptus moonbase penitentiary safari
\ No newline at end of file
+SUBDIRS = blacktooth byblos egyptus moonbase penitentiary safari
diff --git a/gamedata/map/blacktooth/Makefile.am b/gamedata/map/blacktooth/Makefile.am
index 0525f74..f42e96a 100644
--- a/gamedata/map/blacktooth/Makefile.am
+++ b/gamedata/map/blacktooth/Makefile.am
@@ -1,4 +1,4 @@
-gamedatamapblacktoothdir = $(datadir)/@PACKAGE@/map/blacktooth
+gamedatamapblacktoothdir = $(datadir)/@PACKAGE@/gamedata/map/blacktooth
 gamedatamapblacktooth_DATA = blacktooth01.xml \
 			    blacktooth02.xml \
 			    blacktooth03.xml \
diff --git a/gamedata/map/byblos/Makefile.am b/gamedata/map/byblos/Makefile.am
index 72c98dd..f0bc939 100644
--- a/gamedata/map/byblos/Makefile.am
+++ b/gamedata/map/byblos/Makefile.am
@@ -1,4 +1,4 @@
-gamedatamapbyblosdir = $(datadir)/@PACKAGE@/map/byblos
+gamedatamapbyblosdir = $(datadir)/@PACKAGE@/gamedata/map/byblos
 gamedatamapbyblos_DATA = byblos01.xml \
 			byblos02.xml \
 			byblos03.xml \
diff --git a/gamedata/map/egyptus/Makefile.am b/gamedata/map/egyptus/Makefile.am
index 2b4ed56..bad5cbf 100644
--- a/gamedata/map/egyptus/Makefile.am
+++ b/gamedata/map/egyptus/Makefile.am
@@ -1,4 +1,4 @@
-gamedatamapegyptusdir = $(datadir)/@PACKAGE@/map/egyptus
+gamedatamapegyptusdir = $(datadir)/@PACKAGE@/gamedata/map/egyptus
 gamedatamapegyptus_DATA = egyptus01.xml \
 			  egyptus02.xml \
 			  egyptus03.xml \
diff --git a/gamedata/map/moonbase/Makefile.am b/gamedata/map/moonbase/Makefile.am
index 0cc530f..ebafece 100644
--- a/gamedata/map/moonbase/Makefile.am
+++ b/gamedata/map/moonbase/Makefile.am
@@ -1,4 +1,4 @@
-gamedatamapmoonbasedir = $(datadir)/@PACKAGE@/map/moonbase
+gamedatamapmoonbasedir = $(datadir)/@PACKAGE@/gamedata/map/moonbase
 gamedatamapmoonbase_DATA = moonbase01.xml \
 			    moonbase02.xml \
 			    moonbase03.xml \
diff --git a/gamedata/map/penitentiary/Makefile.am b/gamedata/map/penitentiary/Makefile.am
index 7d42f6a..f31c7c5 100644
--- a/gamedata/map/penitentiary/Makefile.am
+++ b/gamedata/map/penitentiary/Makefile.am
@@ -1,4 +1,4 @@
-gamedatamappenitentiarydir = $(datadir)/@PACKAGE@/map/penitentiary
+gamedatamappenitentiarydir = $(datadir)/@PACKAGE@/gamedata/map/penitentiary
 gamedatamappenitentiary_DATA = penitentiary01.xml \
 			      penitentiary02.xml \
 			      penitentiary03.xml \
diff --git a/gamedata/map/safari/Makefile.am b/gamedata/map/safari/Makefile.am
index a7dd568..3989d95 100644
--- a/gamedata/map/safari/Makefile.am
+++ b/gamedata/map/safari/Makefile.am
@@ -1,4 +1,4 @@
-gamedatamapsafaridir = $(datadir)/@PACKAGE@/map/safari
+gamedatamapsafaridir = $(datadir)/@PACKAGE@/gamedata/map/safari
 gamedatamapsafari_DATA = safari01.xml \
 			safari02.xml \
 			safari03.xml \
diff --git a/gamedata/music/Makefile.am b/gamedata/music/Makefile.am
index 589d224..49147c1 100644
--- a/gamedata/music/Makefile.am
+++ b/gamedata/music/Makefile.am
@@ -1,4 +1,4 @@
-gamedatamusicdir = $(datadir)/@PACKAGE@/music
+gamedatamusicdir = $(datadir)/@PACKAGE@/gamedata/music
 gamedatamusic_DATA = CreditsTheme.ogg \
 		    HeadOverHeels.ogg \
 		    MainTheme.ogg
diff --git a/gamedata/savegame/Makefile.am b/gamedata/savegame/Makefile.am
index acecb71..03af3e2 100644
--- a/gamedata/savegame/Makefile.am
+++ b/gamedata/savegame/Makefile.am
@@ -1,2 +1,2 @@
-gamedatasavegamedir = $(datadir)/@PACKAGE@/savegame
+gamedatasavegamedir = $(datadir)/@PACKAGE@/gamedata/savegame
 gamedatasavegame_DATA = savegame.xsd
diff --git a/gamedata/sound/Makefile.am b/gamedata/sound/Makefile.am
index df8f0e5..41fac8c 100644
--- a/gamedata/sound/Makefile.am
+++ b/gamedata/sound/Makefile.am
@@ -1,4 +1,4 @@
-gamedatasounddir = $(datadir)/@PACKAGE@/sound
+gamedatasounddir = $(datadir)/@PACKAGE@/gamedata/sound
 gamedatasound_DATA = adjust.wav \
 		    bighead-robot.wav \
 		    blades.wav \
diff --git a/gamedata/text/Makefile.am b/gamedata/text/Makefile.am
index 8728034..4e82613 100644
--- a/gamedata/text/Makefile.am
+++ b/gamedata/text/Makefile.am
@@ -1,4 +1,4 @@
-gamedatatextdir = $(datadir)/@PACKAGE@/text
+gamedatatextdir = $(datadir)/@PACKAGE@/gamedata/text
 gamedatatext_DATA = language.xml \
 		    language.xsd \
 		    af_ZA.xml \
diff --git a/src/BonusManager.cpp b/src/BonusManager.cpp
index 59d9322..043e0c5 100644
--- a/src/BonusManager.cpp
+++ b/src/BonusManager.cpp
@@ -58,24 +58,31 @@ bool BonusManager::isPresent(const std::string& fileName, const short label)
 }
 
 //--------------------------------------------------------------------------------------------------
-void BonusManager::load(const sgxml::bonus::room_sequence& roomSequence)
+void BonusManager::load(const boost::property_tree::ptree& roomSequence)
 {
-  for(sgxml::bonus::room_const_iterator i = roomSequence.begin(); i != roomSequence.end(); ++i)
-  {
-    this->destroyBonus((*i).filename(), (*i).label());
-  }
+   auto&& roomIter = roomSequence.equal_range("room");
+   for (auto&& i = roomIter.first; i != roomIter.second; ++i)
+   {
+      this->destroyBonus(i->second.get<std::string>("<xmlattr>.filename"),
+                         i->second.get<short>("label"));
+   }
 }
 
 //--------------------------------------------------------------------------------------------------
-void BonusManager::save(sgxml::bonus::room_sequence& roomSequence)
+void BonusManager::save(boost::property_tree::ptree& roomSequence)
 {
-  for(std::list<BonusRoom>::iterator r = this->bonusRooms.begin(); r !=this->bonusRooms.end(); ++r)
-  {
-    for(std::list<short>::iterator b = (*r).getBonusItems().begin(); b != (*r).getBonusItems().end(); ++b)
-    {
-      roomSequence.push_back(sgxml::room(*b, (*r).getFileName()));
-    }
-  }
+   boost::property_tree::ptree room;
+   for (std::list<BonusRoom>::iterator r = this->bonusRooms.begin(); r != this->bonusRooms.end(); ++r)
+   {
+      for (std::list<short>::iterator b = (*r).getBonusItems().begin(); b != (*r).getBonusItems().end(); ++b)
+      {
+         boost::property_tree::ptree xmlTree;
+         xmlTree.put("<xmlattr>.filename", (*r).getFileName());
+         xmlTree.put("label", *b);
+         room.add_child("room", xmlTree);
+      }
+   }
+   roomSequence.add_child("savegame.bonus", room);
 }
 
 //--------------------------------------------------------------------------------------------------
diff --git a/src/BonusManager.hpp b/src/BonusManager.hpp
index efcbfa1..5095af5 100644
--- a/src/BonusManager.hpp
+++ b/src/BonusManager.hpp
@@ -25,7 +25,7 @@
 #include <list>
 #include <string>
 #include <algorithm>
-#include "csxml/SaveGameXML.hpp"
+#include <boost/property_tree/ptree.hpp>
 
 namespace isomot
 {
@@ -83,14 +83,14 @@ public:
    * @param roomSequence Estructura de datos empleada por el archivo XML para guardar 
    * los datos de los bonus ausentes.
    */
-  void load(const sgxml::bonus::room_sequence& roomSequence);
+  void load(const boost::property_tree::ptree& roomSequence);
   
   /**
    * Almacena los bonus ausentes en el archivo que guarda la partida en curso.
    * @param roomSequence Estructura de datos empleada por el archivo XML para guardar 
    * los datos de los bonus ausentes.
    */
-  void save(sgxml::bonus::room_sequence& roomSequence);
+  void save(boost::property_tree::ptree& roomSequence);
   
   /**
    * Elimina los bonus marcados como ausentes en todas las salas.
diff --git a/src/GameFileManager.cpp b/src/GameFileManager.cpp
index 3506854..e6b3ad3 100644
--- a/src/GameFileManager.cpp
+++ b/src/GameFileManager.cpp
@@ -44,46 +44,47 @@ void GameFileManager::assignFishData(const std::string& roomId, short label, int
 //--------------------------------------------------------------------------------------------------
 void GameFileManager::loadGame(const std::string& fileName)
 { 
-  try
-  {
-    std::auto_ptr<sgxml::SaveGameXML> saveGameXML(sgxml::savegame(fileName.c_str()));
+   try
+   {
+      boost::property_tree::ptree xmlTree;
+      boost::property_tree::xml_parser::read_xml(fileName, xmlTree);
     
-    // Establece las salas que ya han sido visitadas.
-    this->isomot->getMapManager()->load(saveGameXML->exploredRooms().visited());
+      // Establece las salas que ya han sido visitadas.
+      this->isomot->getMapManager()->load(xmlTree.get_child("savegame.exploredRooms"));
     
-    // Asigna los bonus que no deben aparecer en esta partida.
-    BonusManager::getInstance()->load(saveGameXML->bonus().room());
+      // Asigna los bonus que no deben aparecer en esta partida.
+      BonusManager::getInstance()->load(xmlTree.get_child("savegame.bonus"));
 
-    if(saveGameXML->freeByblos())
-    {
-      this->gameManager->liberatePlanet(Byblos, false);
-    }
-    if(saveGameXML->freeEgyptus())
-    {
-      this->gameManager->liberatePlanet(Egyptus, false);
-    }
-    if(saveGameXML->freePenitentiary())
-    {
-      this->gameManager->liberatePlanet(Penitentiary, false);
-    }    
-    if(saveGameXML->freeSafari())
-    {
-      this->gameManager->liberatePlanet(Safari, false);
-    }
-    if(saveGameXML->freeBlacktooth())
-    {
-      this->gameManager->liberatePlanet(Blacktooth, false);
-    }
+      if(xmlTree.get<bool>("savegame.freeByblos"))
+      {
+         this->gameManager->liberatePlanet(Byblos, false);
+      }
+      if(xmlTree.get<bool>("savegame.freeEgyptus"))
+      {
+         this->gameManager->liberatePlanet(Egyptus, false);
+      }
+      if(xmlTree.get<bool>("savegame.freePenitentiary"))
+      {
+         this->gameManager->liberatePlanet(Penitentiary, false);
+      }
+      if(xmlTree.get<bool>("savegame.freeSafari"))
+      {
+         this->gameManager->liberatePlanet(Safari, false);
+      }
+      if(xmlTree.get<bool>("savegame.freeBlacktooth"))
+      {
+         this->gameManager->liberatePlanet(Blacktooth, false);
+      }
     
-    // Asigna el estado de los jugadores.
-    this->assignPlayerStatus(saveGameXML->players().player());
-    // Crea las salas iniciales y la posición de los jugadores.
-    this->isomot->start(saveGameXML->players().player());
-  }
-  catch(const xml_schema::exception& e)
-  {
-    std::cout << e << std::endl;
-  }
+      // Asigna el estado de los jugadores.
+      this->assignPlayerStatus(xmlTree.get_child("savegame.players"));
+      // Crea las salas iniciales y la posición de los jugadores.
+      this->isomot->start(xmlTree.get_child("savegame.players"));
+   }
+   catch (const std::runtime_error& e)
+   {
+      std::cerr << e.what() << std::endl;
+   }
 }
 
 //--------------------------------------------------------------------------------------------------
@@ -91,170 +92,162 @@ void GameFileManager::saveGame(const std::string& fileName)
 {
   try
   {
-    // Se almacenan las salas visitadas.
-    sgxml::exploredRooms exploredRooms;
-    sgxml::exploredRooms::visited_sequence& visitedSequence(exploredRooms.visited());
-    this->isomot->getMapManager()->save(visitedSequence);
-    exploredRooms.visited(visitedSequence);
-    
-    // Se almacenan los bonus que se hallan cogido.
-    sgxml::bonus bonus;
-    sgxml::bonus::room_sequence& roomSequence(bonus.room());
-    BonusManager::getInstance()->save(roomSequence);
-    bonus.room(roomSequence);
-    
-    // Se almacena el estado de los jugadores.
-    sgxml::players players;
-    sgxml::players::player_sequence playerSequence(players.player());
-    
-    // El jugador activo.
-    PlayerId activePlayerId = PlayerId(this->label);
-    
-    // Número de vidas.
-    unsigned short lives = 0;
-    switch(activePlayerId)
-    {
-      case Head:
-      case Heels:
-        lives = this->gameManager->getLives(activePlayerId);
-        break;
+     boost::property_tree::ptree xmlTree;
+     xmlTree.put("savegame.<xmlattr>.xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
+     xmlTree.put("savegame.<xmlattr>.xsi:noNamespaceSchemaLocation", "savegame.xsd");
+
+     // Se almacenan las salas visitadas.
+     this->isomot->getMapManager()->save(xmlTree);
+    
+     // Planetas liberados.
+     xmlTree.put("savegame.freeByblos", this->gameManager->isFreePlanet(Byblos));
+     xmlTree.put("savegame.freeEgyptus", this->gameManager->isFreePlanet(Egyptus));
+     xmlTree.put("savegame.freePenitentiary", this->gameManager->isFreePlanet(Penitentiary));
+     xmlTree.put("savegame.freeSafari", this->gameManager->isFreePlanet(Safari));
+     xmlTree.put("savegame.freeBlacktooth", this->gameManager->isFreePlanet(Blacktooth));
+
+     // Se almacenan los bonus que se hallan cogido.
+     BonusManager::getInstance()->save(xmlTree);
+    
+     // Se almacena el estado de los jugadores.
+     // El jugador activo.
+     PlayerId activePlayerId = PlayerId(this->label);
+    
+     // Número de vidas.
+     unsigned short lives = 0;
+     switch(activePlayerId)
+     {
+        case Head:
+        case Heels:
+           lives = this->gameManager->getLives(activePlayerId);
+           break;
         
-      case HeadAndHeels:
-        lives = this->gameManager->getLives(Head) * 100 + this->gameManager->getLives(Heels);
-        break;
+        case HeadAndHeels:
+           lives = this->gameManager->getLives(Head) * 100 + this->gameManager->getLives(Heels);
+           break;
         
-      default:
-        ;
-    }
-    // Posesión de objetos.
-    std::vector<short> tools = this->gameManager->hasTool(activePlayerId);
-    // Almacenamiento de todos los datos.
-    playerSequence.push_back(sgxml::player(true, 
-                                           this->roomId, 
-                                           this->x, 
-                                           this->y, 
-                                           this->z, 
-                                           int(this->direction), 
-                                           Wait,
-                                           lives,
-                                           activePlayerId == Head || activePlayerId == HeadAndHeels ? std::find(tools.begin(), tools.end(), short(Horn)) != tools.end() : false,
-                                           activePlayerId == Heels || activePlayerId == HeadAndHeels ? std::find(tools.begin(), tools.end(), short(Handbag)) != tools.end() : false,
-                                           this->gameManager->getDonuts(activePlayerId),
-                                           this->label));
-    
-    // Es posible que no haya más salas bien porque no haya más jugadores o porque el otro jugador
-    // se encuentre en la misma sala que el jugador activo. 
-    Room* hideRoom = this->isomot->getMapManager()->getHideRoom();
-    Room* activeRoom = this->isomot->getMapManager()->getActiveRoom();
-    PlayerItem* inactivePlayer = (hideRoom != 0 ? hideRoom->getMediator()->getActivePlayer() : activeRoom->getMediator()->getHidePlayer());
-    
-    // Si hay algún otro jugador, se almacenan sus datos.
-    if(inactivePlayer != 0)
-    {
-      PlayerId inactivePlayerId = PlayerId(inactivePlayer->getLabel());
-      std::vector<short> tools = this->gameManager->hasTool(inactivePlayerId);
-      PlayerStartPosition* startPosition = this->isomot->getMapManager()->findPlayerPosition(hideRoom != 0 ? hideRoom->getIdentifier() : activeRoom->getIdentifier(), PlayerId(inactivePlayer->getLabel()));
-      if(startPosition == 0)
-      {
-          startPosition = this->isomot->getMapManager()->findPlayerPosition(activeRoom->getIdentifier(), HeadAndHeels);
-      }
-      playerSequence.push_back(sgxml::player(false, 
-                                             hideRoom != 0 ? hideRoom->getIdentifier() : activeRoom->getIdentifier(), 
-                                             startPosition->getX(),
-                                             startPosition->getY(),
-                                             startPosition->getZ(),
-                                             int(inactivePlayer->getDirection()), 
-                                             startPosition->getEntry(),
-                                             this->gameManager->getLives(inactivePlayerId),
-                                             inactivePlayerId == Head || inactivePlayerId == HeadAndHeels ? std::find(tools.begin(), tools.end(), short(Horn)) != tools.end() : false,
-                                             inactivePlayerId == Heels || inactivePlayerId == HeadAndHeels ? std::find(tools.begin(), tools.end(), short(Handbag)) != tools.end() : false,
-                                             this->gameManager->getDonuts(inactivePlayerId),
-                                             inactivePlayer->getLabel()));
-    }
-    
-    // Almacena los jugadores.
-    players.player(playerSequence);
-    
-    // Creación de la configuración.
-    sgxml::SaveGameXML saveGameXML(exploredRooms,
-                                   this->gameManager->isFreePlanet(Byblos),
-                                   this->gameManager->isFreePlanet(Egyptus),
-                                   this->gameManager->isFreePlanet(Penitentiary),
-                                   this->gameManager->isFreePlanet(Safari),
-                                   this->gameManager->isFreePlanet(Blacktooth),
-                                   bonus,
-                                   players);
-    
-    // Información del esquema que valida la corrección de los datos.
-    xml_schema::namespace_infomap map;
-    map[""].name = "";
-    map[""].schema = "savegame.xsd";
+        default:
+           ;
+     }
+     // Posesión de objetos.
+     std::vector<short> tools = this->gameManager->hasTool(activePlayerId);
+
+     // Almacenamiento de todos los datos.
+     boost::property_tree::ptree players;
+
+     boost::property_tree::ptree activePlayerTree;
+     activePlayerTree.put("<xmlattr>.label", this->label);
+     activePlayerTree.put("active", true);
+     activePlayerTree.put("roomFilename", this->roomId);
+     activePlayerTree.put("x", this->x);
+     activePlayerTree.put("y", this->y);
+     activePlayerTree.put("z", this->z);
+     activePlayerTree.put("direction", int(this->direction));
+     activePlayerTree.put("entry", Wait);
+     activePlayerTree.put("lives", lives);
+     activePlayerTree.put("hasHorn", activePlayerId == Head || activePlayerId == HeadAndHeels ? std::find(tools.begin(), tools.end(), short(Horn)) != tools.end() : false);
+     activePlayerTree.put("hasHandbag", activePlayerId == Heels || activePlayerId == HeadAndHeels ? std::find(tools.begin(), tools.end(), short(Handbag)) != tools.end() : false);
+     activePlayerTree.put("ammo", this->gameManager->getDonuts(activePlayerId));
+     players.add_child("player", activePlayerTree);
+    
+     // Es posible que no haya más salas bien porque no haya más jugadores o porque el otro jugador
+     // se encuentre en la misma sala que el jugador activo.
+     Room* hideRoom = this->isomot->getMapManager()->getHideRoom();
+     Room* activeRoom = this->isomot->getMapManager()->getActiveRoom();
+     PlayerItem* inactivePlayer = (hideRoom != 0 ? hideRoom->getMediator()->getActivePlayer() : activeRoom->getMediator()->getHidePlayer());
+    
+     // Si hay algún otro jugador, se almacenan sus datos.
+     if(inactivePlayer != 0)
+     {
+        PlayerId inactivePlayerId = PlayerId(inactivePlayer->getLabel());
+        std::vector<short> tools = this->gameManager->hasTool(inactivePlayerId);
+        PlayerStartPosition* startPosition = this->isomot->getMapManager()->findPlayerPosition(hideRoom != 0 ? hideRoom->getIdentifier() : activeRoom->getIdentifier(), PlayerId(inactivePlayer->getLabel()));
+        if(startPosition == 0)
+        {
+           startPosition = this->isomot->getMapManager()->findPlayerPosition(activeRoom->getIdentifier(), HeadAndHeels);
+        }
+
+        boost::property_tree::ptree inactivePlayerTree;
+        inactivePlayerTree.put("<xmlattr>.label", inactivePlayer->getLabel());
+        inactivePlayerTree.put("active", false);
+        inactivePlayerTree.put("roomFilename", hideRoom != 0 ? hideRoom->getIdentifier() : activeRoom->getIdentifier());
+        inactivePlayerTree.put("x", startPosition->getX());
+        inactivePlayerTree.put("y", startPosition->getY());
+        inactivePlayerTree.put("z", startPosition->getZ());
+        inactivePlayerTree.put("direction", int(inactivePlayer->getDirection()));
+        inactivePlayerTree.put("entry", startPosition->getEntry());
+        inactivePlayerTree.put("lives", this->gameManager->getLives(inactivePlayerId));
+        inactivePlayerTree.put("hasHorn", inactivePlayerId == Head || inactivePlayerId == HeadAndHeels ? std::find(tools.begin(), tools.end(), short(Horn)) != tools.end() : false);
+        inactivePlayerTree.put("hasHandbag", inactivePlayerId == Heels || inactivePlayerId == HeadAndHeels ? std::find(tools.begin(), tools.end(), short(Handbag)) != tools.end() : false);
+        inactivePlayerTree.put("ammo", this->gameManager->getDonuts(inactivePlayerId));
+        players.add_child("player", inactivePlayerTree);
+
+        xmlTree.add_child("savegame.players", players);
+     }
     
-    // Creación del archivo.
-    std::ofstream outputFile(fileName.c_str());
-    sgxml::savegame(outputFile, saveGameXML, map);
+     // Grabación del archivo.
+     auto settings = boost::property_tree::xml_parser::xml_writer_make_settings<boost::property_tree::ptree::key_type>(' ', 3);
+     boost::property_tree::xml_parser::write_xml(fileName, xmlTree, std::locale(), settings);
   }
-  catch(const xml_schema::exception& e)
+  catch (const std::runtime_error& e)
   {
-    std::cout << e << std::endl;
+     std::cerr << e.what() << std::endl;
   }
 }
 
-//--------------------------------------------------------------------------------------------------
-void GameFileManager::assignPlayerStatus(const sgxml::players::player_sequence& playerSequence)
+void GameFileManager::assignPlayerStatus(const boost::property_tree::ptree& playerSequence)
 {
-  for(sgxml::players::player_const_iterator i = playerSequence.begin(); i != playerSequence.end(); ++i)
-  {   
-    sgxml::player data = *i;
-    
-    unsigned char headLives = 0;
-    unsigned char heelsLives = 0;
-    
-    // Si se va a crear al jugador compuesto se obtienen las vidas de los jugadores simples.
-    // Se utiliza la fórmula: Vidas H&H = Vidas Head * 100 + Vidas Heels.
-    if(data.label() == HeadAndHeels)
-    {
-      unsigned short lives = data.lives();
-      
-      while(lives > 100)
+   auto&& playerIter = playerSequence.equal_range("player");
+   for (auto&& i = playerIter.first; i != playerIter.second; ++i)
+   {
+      unsigned char headLives = 0;
+      unsigned char heelsLives = 0;
+
+      // Si se va a crear al jugador compuesto se obtienen las vidas de los jugadores simples.
+      // Se utiliza la fórmula: Vidas H&H = Vidas Head * 100 + Vidas Heels.
+      if (i->second.get<short>("<xmlattr>.label") == HeadAndHeels)
       {
-        lives -= 100;
-        headLives++;
+         unsigned short lives = i->second.get<short>("lives");
+
+         while (lives > 100)
+         {
+            lives -= 100;
+            headLives++;
+         }
+         heelsLives = static_cast<unsigned char>(lives);
       }
-      heelsLives = static_cast<unsigned char>(lives);
-    }
-    
-    switch(data.label())
-    {
-      case Head:
-        this->gameManager->setHeadLives(data.lives());
-        this->gameManager->setHorn(data.hasHorn());
-        this->gameManager->setDonuts(data.ammo());
-        this->gameManager->setHighSpeed(0);
-        this->gameManager->setHeadShield(0);
-        break;
-      
-      case Heels:
-        this->gameManager->setHeelsLives(data.lives());
-        this->gameManager->setHandbag(data.hasHandbag());
-        this->gameManager->setHighJumps(0);
-        this->gameManager->setHeelsShield(0);
-        break;
-        
-      case HeadAndHeels:
-        
-        this->gameManager->setHeadLives(headLives);
-        this->gameManager->setHorn(data.hasHorn());
-        this->gameManager->setDonuts(data.ammo());
-        this->gameManager->setHeelsLives(heelsLives);
-        this->gameManager->setHandbag(data.hasHandbag());
-        this->gameManager->setHighSpeed(0);
-        this->gameManager->setHighJumps(0);
-        this->gameManager->setHeadShield(0);
-        this->gameManager->setHeelsShield(0);
-        break;
-    }
-  }
+
+      switch (i->second.get<short>("<xmlattr>.label"))
+      {
+         case Head:
+            this->gameManager->setHeadLives(i->second.get<short>("lives"));
+            this->gameManager->setHorn(i->second.get<bool>("hasHorn"));
+            this->gameManager->setDonuts(i->second.get<unsigned short>("ammo"));
+            this->gameManager->setHighSpeed(0);
+            this->gameManager->setHeadShield(0);
+            break;
+
+         case Heels:
+            this->gameManager->setHeelsLives(i->second.get<short>("lives"));
+            this->gameManager->setHandbag(i->second.get<bool>("hasHandbag"));
+            this->gameManager->setHighJumps(0);
+            this->gameManager->setHeelsShield(0);
+            break;
+
+         case HeadAndHeels:
+
+            this->gameManager->setHeadLives(headLives);
+            this->gameManager->setHorn(i->second.get<bool>("hasHorn"));
+            this->gameManager->setDonuts(i->second.get<unsigned short>("ammo"));
+            this->gameManager->setHeelsLives(heelsLives);
+            this->gameManager->setHandbag(i->second.get<bool>("hasHandbag"));
+            this->gameManager->setHighSpeed(0);
+            this->gameManager->setHighJumps(0);
+            this->gameManager->setHeadShield(0);
+            this->gameManager->setHeelsShield(0);
+            break;
+      }
+   }
 }
 
 }
diff --git a/src/GameFileManager.hpp b/src/GameFileManager.hpp
index e9a9279..e4abbe3 100644
--- a/src/GameFileManager.hpp
+++ b/src/GameFileManager.hpp
@@ -24,7 +24,7 @@
 
 #include <string>
 #include "Ism.hpp"
-#include "csxml/SaveGameXML.hpp"
+#include <boost/property_tree/xml_parser.hpp>
 
 namespace isomot
 {
@@ -84,7 +84,7 @@ private:
    * Establece el estado de los jugadores (vidas, bocina, bolso y rosquillas).
    * @param playerSequence Datos obtenidos de los jugadores de la partida cargada.
    */
-  void assignPlayerStatus(const sgxml::players::player_sequence& playerSequence);
+  void assignPlayerStatus(const boost::property_tree::ptree& playerSequence);
   
 private:
   
diff --git a/src/GameManager.hpp b/src/GameManager.hpp
index 1f9e40f..57f0a4c 100644
--- a/src/GameManager.hpp
+++ b/src/GameManager.hpp
@@ -28,7 +28,6 @@
 #include <sstream>
 #include <iostream>
 #include <fstream>
-#include "csxml/SaveGameXML.hpp"
 #include "Ism.hpp"
 
 namespace isomot
diff --git a/src/Ism.cpp b/src/Ism.cpp
index 818c4ea..bc9437a 100644
--- a/src/Ism.cpp
+++ b/src/Ism.cpp
@@ -35,26 +35,29 @@ void copyFile(const std::string& source, const std::string& destination)
 std::string HomePath;
 std::string homePath()
 {
-  if(HomePath.empty())
-  {
+   if(HomePath.empty())
+   {
 #ifdef __WIN32
-      HomePath = sharePath();
+      char* cpath = getenv("USERPROFILE");
+      assert(cpath != 0);
+      HomePath = std::string(cpath) + "/Documents/Head over Heels/";
 #else
       char* cpath = getenv("HOME");
       assert(cpath != 0);
       HomePath = std::string(cpath) + "/.headoverheels/";
+#endif
+
       if(!file_exists(HomePath.c_str(), FA_DIREC, 0))
       {
-        mkdir(HomePath.c_str(), S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);
-        mkdir((HomePath + "savegame/").c_str(), S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);
-        copyFile(sharePath() + "configuration.xsd", HomePath + "configuration.xsd");
-        copyFile(sharePath() + "configuration.xml", HomePath + "configuration.xml");
-        copyFile(sharePath() + "savegame/savegame.xsd", HomePath + "savegame/savegame.xsd");
+         mkdir(HomePath.c_str(), S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);
+         mkdir((HomePath + "savegame/").c_str(), S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);
+         copyFile(sharePath() + "configuration.xsd", HomePath + "configuration.xsd");
+         copyFile(sharePath() + "configuration.xml", HomePath + "configuration.xml");
+         copyFile(sharePath() + "savegame/savegame.xsd", HomePath + "savegame/savegame.xsd");
       }
-#endif
-  }
+   }
 
-  return HomePath;
+   return HomePath;
 }
 
 //--------------------------------------------------------------------------------------------------
@@ -63,11 +66,15 @@ std::string sharePath()
 {
   if(SharePath.empty())
   {
+#ifdef DEPLOY
     char cpath[256];
     get_executable_name(cpath, 256);
     char* filename = get_filename(cpath);
     SharePath = std::string(cpath, strlen(cpath) - strlen(filename) - strlen("bin/"));
-    SharePath += "share/headoverheels/";
+    SharePath += "share/headoverheels/gamedata/";
+#else
+    SharePath = "gamedata/";
+#endif
   }
 
   return SharePath;
diff --git a/src/Isomot.cpp b/src/Isomot.cpp
index 75a334a..79f8dd8 100644
--- a/src/Isomot.cpp
+++ b/src/Isomot.cpp
@@ -71,7 +71,7 @@ void Isomot::start()
 }
 
 //--------------------------------------------------------------------------------------------------
-void Isomot::start(const sgxml::players::player_sequence& playerSequence)
+void Isomot::start(const boost::property_tree::ptree& playerSequence)
 {
   this->isEndRoom = false;
 
@@ -96,9 +96,10 @@ void Isomot::start(const sgxml::players::player_sequence& playerSequence)
   }
 
   // Se crean las salas iniciales.
-  for(sgxml::players::player_const_iterator i = playerSequence.begin(); i != playerSequence.end(); ++i)
+  auto&& playerIter = playerSequence.equal_range("player");
+  for (auto&& i = playerIter.first; i != playerIter.second; ++i)
   {
-    this->mapManager->startOldGame(*i);
+    this->mapManager->startOldGame(i->second);
   }
 }
 
diff --git a/src/Isomot.hpp b/src/Isomot.hpp
index 1c8b129..56b8197 100644
--- a/src/Isomot.hpp
+++ b/src/Isomot.hpp
@@ -26,7 +26,7 @@
 #ifdef __WIN32
   #include <winalleg.h>
 #endif
-#include "csxml/SaveGameXML.hpp"
+#include <boost/property_tree/ptree.hpp>
 
 namespace isomot
 {
@@ -61,7 +61,7 @@ public:
    * Crea dos salas a partir de los datos contenidos en el archivo XML donde se guarda una partida
    * y pone en marcha el motor isométrico.
    */
-  void start(const sgxml::players::player_sequence& playerSequence);
+  void start(const boost::property_tree::ptree& playerSequence);
 
   /**
    * Detiene el motor isométrico.
diff --git a/src/ItemDataManager.cpp b/src/ItemDataManager.cpp
index b292d35..d0eb5a5 100644
--- a/src/ItemDataManager.cpp
+++ b/src/ItemDataManager.cpp
@@ -1,434 +1,431 @@
 #include "ItemDataManager.hpp"
-#include "Exception.hpp"
 #include "Ism.hpp"
-#include <fstream>
 
 namespace isomot
 {
 
-//--------------------------------------------------------------------------------------------------
 ItemDataManager::ItemDataManager(const std::string& fileName)
+   :
+   fileName{fileName}
 {
-  this->fileName = fileName;
+
 }
 
-//--------------------------------------------------------------------------------------------------
 ItemDataManager::~ItemDataManager()
 {
-  std::for_each(itemData.begin(), itemData.end(), destroyItemData);
+   std::for_each(this->itemDataVector.begin(), this->itemDataVector.end(), destroyItemData);
 }
 
-//--------------------------------------------------------------------------------------------------
 void ItemDataManager::load()
 { 
-  // Carga el archivo XML especificado y almacena los datos XML en la lista.
-  try
-  {
-    std::auto_ptr<ixml::ItemsXML> itemsXML(ixml::items((isomot::sharePath() + fileName).c_str()));
-
-    for(ixml::ItemsXML::item_const_iterator i = itemsXML->item().begin(); i != itemsXML->item().end(); ++i)
-    {
-      std::auto_ptr<ItemData> item(new ItemData);
-      
-      // Identificador único y exclusivo del elemento.
-      item->label = (*i).label();      
-      // Número de fotogramas en función de la dirección del elemento.
-      item->directionFrames = (*i).directionFrames();
-      // Elemento ofensivo o inofensivo.
-      item->mortal = (*i).mortal();
-      // Cada cuántos milisegundos cae el elemento.
-      item->weight = (*i).weight();
-      // Cada cuántos milisegundos cambian los fotogramas de la secuencia de animación.
-      item->framesDelay = (*i).framesDelay();
-      // Cada cuántos milisegundos se desplaza el elemento una unidad isométrica.
-      item->speed = (*i).speed();
-      // Ruta a los gráficos del elemento.
-      item->bitmap = isomot::sharePath() + (*i).bitmap().file();
-      // Anchura en píxeles de un fotograma.
-      item->frameWidth = (*i).bitmap().frameWidth();
-      // Altura en píxeles de un fotograma.
-      item->frameHeight = (*i).bitmap().frameHeight();
-      // Se almacenan los fotogramas en el vector motion siempre que el elemento no sea una puerta.
-      if(!(*i).door().present())
+   // Carga el archivo XML especificado y almacena los datos XML en la lista.
+   try
+   {
+      boost::property_tree::ptree xmlTree;
+      boost::property_tree::xml_parser::read_xml(isomot::sharePath() + fileName, xmlTree);
+
+      auto&& itemIter = xmlTree.get_child("items").equal_range("item");
+      for (auto&& i = itemIter.first; i != itemIter.second; ++i)
       {
-        createBitmapFrames(item.get());
+         processItem(i->second);
       }
-      
-      // El elemento puede no tener sombra.
-      if((*i).shadow().present())
+   }
+   catch (const std::runtime_error& e)
+   {
+      std::cerr << e.what() << std::endl;
+   }
+}
+
+void ItemDataManager::processItem(const boost::property_tree::ptree& item)
+{
+   ItemData itemData;
+
+   // Identificador único y exclusivo del elemento.
+   itemData.label = item.get<short>("<xmlattr>.label");
+   // Número de fotogramas en función de la dirección del elemento.
+   itemData.directionFrames = item.get<unsigned char>("directionFrames");
+   // Elemento ofensivo o inofensivo.
+   itemData.mortal = item.get<bool>("mortal");
+   // Cada cuántos milisegundos cae el elemento.
+   itemData.weight = item.get<double>("weight");
+   // Cada cuántos milisegundos cambian los fotogramas de la secuencia de animación.
+   itemData.framesDelay = item.get<double>("framesDelay");
+   // Cada cuántos milisegundos se desplaza el elemento una unidad isométrica.
+   itemData.speed = item.get<double>("speed");
+   // Ruta a los gráficos del elemento.
+   itemData.bitmap = isomot::sharePath() + item.get<std::string>("bitmap.<xmlattr>.file");
+   // Anchura en píxeles de un fotograma.
+   itemData.frameWidth = item.get<int>("bitmap.frameWidth");
+   // Altura en píxeles de un fotograma.
+   itemData.frameHeight = item.get<int>("bitmap.frameHeight");
+
+   // Almacena las sombras del elemento.
+   processShadow(item, itemData);
+
+   // Sólo unos pocos elementos tienen fotogramas extra.
+   itemData.extraFrames = item.get("extraFrames", 0);
+
+   // Secuencia de animación.
+   auto&& frameIter = item.equal_range( "frame" );
+   for (auto&& i = frameIter.first; i != frameIter.second; ++i)
+   {
+      itemData.frames.push_back(std::stoi(i->second.data()));
+   }
+
+   // ¿Es una puerta?
+   bool isDoor = !item.get("door", "").empty();
+
+   // Se almacenan los fotogramas en el vector motion siempre que el elemento no sea una puerta.
+   if (!isDoor)
+   {
+      createBitmapFrames(itemData);
+
+      // Anchura en el eje X en unidades isométricas del elemento.
+      itemData.widthX = item.get<int>("widthX");
+      // Anchura en el eje Y en unidades isométricas del elemento.
+      itemData.widthY = item.get<int>("widthY");
+      // Anchura en el eje Z en unidades isométricas del elemento; su altura.
+      itemData.height = item.get<int>("height");
+
+      // Los datos del elemento simple se incorporan a la lista.
+      this->itemDataVector.push_back(itemData);
+   }
+   else
+   {
+      processDoor(item, itemData);
+   }
+}
+
+void ItemDataManager::processShadow(const boost::property_tree::ptree& item, ItemData& itemData)
+{
+   // El elemento puede no tener sombra.
+   if (std::string shadowFile{item.get("shadow.<xmlattr>.file", "")}; !shadowFile.empty())
+   {
+      // Archivo de la sombra del elemento.
+      itemData.shadow = isomot::sharePath() + shadowFile;
+      // Anchura en píxeles de un fotograma de sombra.
+      itemData.shadowWidth = item.get<int>("shadow.shadowWidth");
+      // Altura en píxeles de un fotograma de sombra.
+      itemData.shadowHeight = item.get<int>("shadow.shadowHeight");
+      // Se almacenan los fotogramas en el vector shadows.
+      createShadowFrames(itemData);
+   }
+}
+
+void ItemDataManager::processDoor(const boost::property_tree::ptree& item, const ItemData& itemData)
+{
+   // Si el elemento es una puerta, tiene tres parámetros que definen sus dimensiones.
+   // Una puerta en realidad son tres elementos distintos: dintel, jamba izquierda y jamba derecha.
+   ItemData lintel(itemData);
+   ItemData leftJamb(itemData);
+   ItemData rightJamb(itemData);
+
+   // Dimensiones de las partes de una puerta.
+   DoorMeasures dm;
+
+   // Anchura espacial en el eje X de las tres partes de la puerta.
+   // Se almacenan en el siguiente orden: jamba izquierda, jamba derecha y dintel.
+   auto&& widthXIter = item.equal_range( "widthX" );
+   for (auto&& i = widthXIter.first; i != widthXIter.second; ++i)
+   {
+      if (dm.leftJambWidthX == 0)
       {
-        // Ruta a la sombra del elemento.
-        item->shadow = isomot::sharePath() + (*i).shadow().get().file();
-        // Anchura en píxeles de un fotograma de sombra.
-        item->shadowWidth = (*i).shadow().get().shadowWidth();
-        // Altura en píxeles de un fotograma de sombra.
-        item->shadowHeight = (*i).shadow().get().shadowHeight();
-        // Se almacenan los fotogramas en el vector shadows.
-        createShadowFrames(item.get());
+        leftJamb.widthX = dm.leftJambWidthX = std::stoi(i->second.data());
       }
-      
-      // Sólo unos pocos elementos tienen fotogramas extra.
-      if((*i).extraFrames().present())
+      else if (dm.rightJambWidthX == 0)
       {
-        item->extraFrames = (*i).extraFrames().get();
+        rightJamb.widthX = dm.rightJambWidthX = std::stoi(i->second.data());
       }
-      
-      // Secuencia de animación.
-      for(ixml::item::frame_const_iterator j = (*i).frame().begin(); j != (*i).frame().end(); ++j)
+      else if (dm.lintelWidthX == 0)
       {
-        item->frames.push_back(*j);
+        lintel.widthX = dm.lintelWidthX = std::stoi(i->second.data());
       }
-
-      // Si el elemento es una puerta, tiene tres parámetros que definen sus dimensiones.
-      if((*i).door().present())
-      {
-        // Una puerta en realidad son tres elementos distintos: dintel, jamba izquierda y jamba derecha.
-        ItemData lintel(*item);
-        ItemData leftJamb(*item);
-        ItemData rightJamb(*item);
-        // Dimensiones de las partes de una puerta.
-        DoorMeasures dm;
-        
-        // Anchura espacial en el eje X de las tres partes de la puerta.
-        // Se almacenan en el siguiente orden: jamba izquierda, jamba derecha y dintel.
-        for(ixml::item::widthX_const_iterator j = (*i).widthX().begin(); j != (*i).widthX().end(); ++j)
-        {
-          if(dm.leftJambWidthX == 0)
-          {
-            leftJamb.widthX = dm.leftJambWidthX = *j;
-          }
-          else if(dm.rightJambWidthX == 0)
-          {
-            rightJamb.widthX = dm.rightJambWidthX = *j;
-          }
-          else if(dm.lintelWidthX == 0)
-          {
-            lintel.widthX = dm.lintelWidthX = *j;
-          }
-        }
+   }
         
-        // Anchura espacial en el eje Y de las tres partes de la puerta.
-        // Se almacenan en el siguiente orden: jamba izquierda, jamba derecha y dintel.
-        for(ixml::item::widthY_const_iterator j = (*i).widthY().begin(); j != (*i).widthY().end(); ++j)
-        {
-          if(dm.leftJambWidthY == 0)
-          {
-            leftJamb.widthY = dm.leftJambWidthY = *j;
-          }
-          else if(dm.rightJambWidthY == 0)
-          {
-            rightJamb.widthY = dm.rightJambWidthY = *j;
-          }
-          else if(dm.lintelWidthY == 0)
-          {
-            lintel.widthY = dm.lintelWidthY = *j;
-          }
-        }  
-        
-        // Altura espacial de las tres partes de la puerta.
-        // Se almacenan en el siguiente orden: jamba izquierda, jamba derecha y dintel.
-        for(ixml::item::height_const_iterator j = (*i).height().begin(); j != (*i).height().end(); ++j)
-        {
-          if(dm.leftJambHeight == 0)
-          {
-            leftJamb.height = dm.leftJambHeight = *j;
-          }
-          else if(dm.rightJambHeight == 0)
-          {
-            rightJamb.height = dm.rightJambHeight = *j;
-          }
-          else if(dm.lintelHeight == 0)
-          {
-            lintel.height = dm.lintelHeight = *j;
-          }
-        }
-
-        // Se cargan el gráfico de la puerta al completo y se obtienen los gráficos de sus tres partes.
-        BITMAP* gfx = load_bitmap(item->bitmap.c_str(), 0);
-        if(gfx == 0) throw "Bitmap " + item->bitmap + " not found.";
-        
-        // Creación de la jamba izquierda.
-        BITMAP* left = cutOutLeftJamb(gfx, dm, (*i).door().get());
-        leftJamb.motion.push_back(left);
-        this->itemData.push_back(leftJamb);
-        
-        // Creación de la jamba derecha.
-        BITMAP* right = cutOutRightJamb(gfx, dm, (*i).door().get());
-        rightJamb.label += 1;
-        rightJamb.motion.push_back(right);
-        this->itemData.push_back(rightJamb);
-        
-        // Creación del dintel.
-        BITMAP* top = cutOutLintel(gfx, dm, (*i).door().get());
-        lintel.label += 2;
-        lintel.motion.push_back(top);
-        this->itemData.push_back(lintel);
-
-        // La imagen original no se volverá a utilizar.
-        destroy_bitmap(gfx);
+   // Anchura espacial en el eje Y de las tres partes de la puerta.
+   // Se almacenan en el siguiente orden: jamba izquierda, jamba derecha y dintel.
+   auto&& widthYIter = item.equal_range( "widthY" );
+   for (auto&& i = widthYIter.first; i != widthYIter.second; ++i)
+   {
+      if (dm.leftJambWidthY == 0)
+      {
+         leftJamb.widthY = dm.leftJambWidthY = std::stoi(i->second.data());
+      }
+      else if (dm.rightJambWidthY == 0)
+      {
+         rightJamb.widthY = dm.rightJambWidthY = std::stoi(i->second.data());
       }
-      else
+      else if (dm.lintelWidthY == 0)
       {
-        // Anchura en el eje X en unidades isométricas del elemento.
-        item->widthX = *((*i).widthX()).begin();
-        // Anchura en el eje Y en unidades isométricas del elemento.
-        item->widthY = *((*i).widthY()).begin();
-        // Anchura en el eje Z en unidades isométricas del elemento; su altura.
-        item->height = *((*i).height()).begin();
+         lintel.widthY = dm.lintelWidthY = std::stoi(i->second.data());
+      }
+   }
         
-        // Los datos del elemento simple se incorporan a la lista.
-        this->itemData.push_back(*item.get());
+   // Altura espacial de las tres partes de la puerta.
+   // Se almacenan en el siguiente orden: jamba izquierda, jamba derecha y dintel.
+   auto&& heightIter = item.equal_range( "height" );
+   for (auto&& i = heightIter.first; i != heightIter.second; ++i)
+   {
+      if (dm.leftJambHeight == 0)
+      {
+         leftJamb.height = dm.leftJambHeight = std::stoi(i->second.data());
       }
-    }
-  }
-  catch(const xml_schema::exception& e)
-  {
-    std::cerr << e << std::endl;
-  }
-  catch(const Exception& e)
-  {
-    std::cerr << e.what() << std::endl;
-  }  
-}
+      else if (dm.rightJambHeight == 0)
+      {
+         rightJamb.height = dm.rightJambHeight = std::stoi(i->second.data());
+      }
+      else if (dm.lintelHeight == 0)
+      {
+         lintel.height = dm.lintelHeight = std::stoi(i->second.data());
+      }
+   }
 
-//--------------------------------------------------------------------------------------------------
-ItemData* ItemDataManager::find(const short label)
-{
-  std::list<ItemData>::iterator i = std::find_if(itemData.begin(), itemData.end(), std::bind2nd(EqualItemData(), label));
-  ItemData* data = (i != itemData.end() ? static_cast<ItemData*>(&(*i)) : 0);
-  
-  return data;
+   // Se cargan el gráfico de la puerta al completo y se obtienen los gráficos de sus tres partes.
+   BITMAP* gfx = load_bitmap(itemData.bitmap.c_str(), 0);
+   if (gfx == nullptr)
+   {
+      throw std::logic_error{"Bitmap " + itemData.bitmap + " not found"};
+   }
+        
+   std::string door{item.get<std::string>("door")};
+
+   // Creación de la jamba izquierda.
+   BITMAP* left = cutOutLeftJamb(gfx, dm, door);
+   leftJamb.motion.push_back(left);
+   this->itemDataVector.push_back(leftJamb);
+        
+   // Creación de la jamba derecha.
+   BITMAP* right = cutOutRightJamb(gfx, dm, door);
+   rightJamb.label += 1;
+   rightJamb.motion.push_back(right);
+   this->itemDataVector.push_back(rightJamb);
+        
+   // Creación del dintel.
+   BITMAP* top = cutOutLintel(gfx, dm, door);
+   lintel.label += 2;
+   lintel.motion.push_back(top);
+   this->itemDataVector.push_back(lintel);
+
+   // La imagen original no se volverá a utilizar.
+   destroy_bitmap(gfx);
 }
 
-//--------------------------------------------------------------------------------------------------
-ItemDataManager::DoorMeasures::DoorMeasures()
+ItemData* ItemDataManager::find(short label)
 {
-  lintelWidthX = lintelWidthY = lintelHeight = 0;
-  leftJambWidthX = leftJambWidthY = leftJambHeight = 0;
-  rightJambWidthX = rightJambWidthY = rightJambHeight = 0;    
+   auto&& i = std::find_if(this->itemDataVector.begin(), this->itemDataVector.end(),
+                           [label](const ItemData& itemData) {
+                              return itemData.label == label;
+                           });
+
+   return (i != this->itemDataVector.end() ? &(*i) : nullptr);
 }
 
-//--------------------------------------------------------------------------------------------------
-ItemData* ItemDataManager::createBitmapFrames(ItemData* itemData)
+void ItemDataManager::createBitmapFrames(ItemData& itemData)
 { 
-  try
-  {
-    // Datos necesarios.
-    if(itemData->bitmap.empty() || itemData->frameWidth == 0 || itemData->frameHeight == 0)
-    {
-      throw "Insufficient data for ItemDataManager::createBitmapFrames.";
-    }
+   // Datos necesarios.
+   if (itemData.bitmap.empty() || itemData.frameWidth == 0 || itemData.frameHeight == 0)
+   {
+      throw std::logic_error{"Insufficient data for ItemDataManager::createBitmapFrames"};
+   }
     
-    // Se cargan los gráficos del elemento y si es necesario se crean los distintos fotogramas.
-    BITMAP* gfx = load_bitmap(itemData->bitmap.c_str(), 0);    
-    if(gfx == 0) throw "Bitmap " + itemData->bitmap + " not found.";
-
-    // Trocea la imagen en los distintos fotogramas y se almacenan en el vector.
-    for(int y = 0; y < gfx->h / itemData->frameHeight; y++)
-    {
-      for(int x = 0; x < gfx->w / itemData->frameWidth; x++)
+   // Se cargan los gráficos del elemento y si es necesario se crean los distintos fotogramas.
+   BITMAP* gfx = load_bitmap(itemData.bitmap.c_str(), 0);
+   if (gfx == nullptr)
+   {
+      throw std::logic_error{"Bitmap " + itemData.bitmap + " not found"};
+   }
+
+   // Trocea la imagen en los distintos fotogramas y se almacenan en el vector.
+   for (int y = 0; y < gfx->h / itemData.frameHeight; y++)
+   {
+      for (int x = 0; x < gfx->w / itemData.frameWidth; x++)
       {
-        BITMAP* frame = create_bitmap_ex(32, itemData->frameWidth, itemData->frameHeight);
-        blit(gfx, frame, x * itemData->frameWidth, y * itemData->frameHeight, 0, 0, frame->w, frame->h);
-        itemData->motion.push_back(frame);
+         BITMAP* frame = create_bitmap_ex(32, itemData.frameWidth, itemData.frameHeight);
+         blit(gfx, frame, x * itemData.frameWidth, y * itemData.frameHeight,
+                   0, 0,
+                   frame->w, frame->h);
+         itemData.motion.push_back(frame);
       }
-    }
+   }
     
-    // La imagen original no se volverá a utilizar.
-    destroy_bitmap(gfx);
-  }
-  catch(const Exception& e)
-  {
-    std::cerr << e.what() << std::endl;
-    return 0;
-  }
-  
-  return itemData;
+   // La imagen original no se volverá a utilizar.
+   destroy_bitmap(gfx);
 }
 
-//--------------------------------------------------------------------------------------------------
-ItemData* ItemDataManager::createShadowFrames(ItemData* itemData)
+void ItemDataManager::createShadowFrames(ItemData& itemData)
 {  
-  try
-  {
-    // Datos necesarios.
-    if(itemData->shadow.empty() || itemData->shadowWidth == 0 || itemData->shadowHeight == 0)
-    {
-      throw "Insufficient data for ItemDataManager::createShadowFrames.";
-    }
+   // Datos necesarios.
+   if (itemData.shadow.empty() || itemData.shadowWidth == 0 || itemData.shadowHeight == 0)
+   {
+      throw std::logic_error{"Insufficient data for ItemDataManager::createShadowFrames"};
+   }
     
-    // Se cargan los gráficos del elemento y si es necesario se crean los distintos fotogramas.
-    BITMAP* gfx = load_bitmap(itemData->shadow.c_str(), 0);
-    if(gfx == 0) throw "Bitmap " + itemData->shadow + " not found.";
-
-    // Trocea la imagen en los distintos fotogramas y se almacenan en el vector.
-    for(int y = 0; y < gfx->h / itemData->shadowHeight; y++)
-    {
-      for(int x = 0; x < gfx->w / itemData->shadowWidth; x++)
+   // Se cargan los gráficos del elemento y si es necesario se crean los distintos fotogramas.
+   BITMAP* gfx = load_bitmap(itemData.shadow.c_str(), 0);
+   if (gfx == nullptr)
+   {
+      throw std::logic_error{"Bitmap " + itemData.shadow + " not found"};
+   }
+
+   // Trocea la imagen en los distintos fotogramas y se almacenan en el vector.
+   for (int y = 0; y < gfx->h / itemData.shadowHeight; y++)
+   {
+      for(int x = 0; x < gfx->w / itemData.shadowWidth; x++)
       {
-        BITMAP* frame = create_bitmap_ex(32, itemData->shadowWidth, itemData->shadowHeight);
-        blit(gfx, frame, x * itemData->shadowWidth, y * itemData->shadowHeight, 0, 0, frame->w, frame->h);
-        itemData->shadows.push_back(frame);
+         BITMAP* frame = create_bitmap_ex(32, itemData.shadowWidth, itemData.shadowHeight);
+         blit(gfx, frame, x * itemData.shadowWidth, y * itemData.shadowHeight,
+                   0, 0,
+                   frame->w, frame->h);
+         itemData.shadows.push_back(frame);
       }
-    }
+   }
     
-    // La imagen original no se volverá a utilizar.
-    destroy_bitmap(gfx);
-  }
-  catch(const Exception& e)
-  {
-    std::cerr << e.what() << std::endl;
-    return 0;
-  }
-  
-  return itemData;
+   // La imagen original no se volverá a utilizar.
+   destroy_bitmap(gfx);
 }
 
-//--------------------------------------------------------------------------------------------------
-BITMAP* ItemDataManager::cutOutLintel(BITMAP* door, const DoorMeasures& dm, const ixml::door::value type)
+BITMAP* ItemDataManager::cutOutLintel(BITMAP* door, const DoorMeasures& dm, const std::string& type)
 {
-  bool ns = (type == ixml::door::north || type == ixml::door::south);
+   bool ns{type == "north" || type == "south"};
   
-  // Parte superior de la puerta.
-  BITMAP* top = create_bitmap_ex(32, (dm.lintelWidthX << 1) + (dm.lintelWidthY << 1), 
-                                      dm.lintelHeight + dm.lintelWidthY + dm.lintelWidthX);
-  // El color de fondo es magenta.
-  clear_to_color(top, makecol(255, 0, 255));
-
-  // Copia la zona a recortar si la puerta está orientada al norte o al sur.
-  if(ns)
-  {
-    // Copia la zona rectangular.
-    blit(door, top, 0, 0, 0, 0, top->w, dm.lintelHeight + dm.lintelWidthX);
-
-    int delta = top->w - 1;
-    int noPixelIndex = top->w - ((dm.rightJambWidthX + dm.rightJambWidthY) << 1) + 1;
-    int yStart = noPixelIndex;
-    int yEnd = noPixelIndex - 1;
-
-    acquire_bitmap(top);
-
-    for(int x = dm.lintelHeight + dm.lintelWidthX; x < top->h; x++)
-    {
-      for(int y = delta; y >= 0; y--)
+   // Parte superior de la puerta.
+   BITMAP* top = create_bitmap_ex(32, (dm.lintelWidthX << 1) + (dm.lintelWidthY << 1),
+                                       dm.lintelHeight + dm.lintelWidthY + dm.lintelWidthX);
+   // El color de fondo es magenta.
+   clear_to_color(top, makecol(255, 0, 255));
+
+   // Copia la zona a recortar si la puerta está orientada al norte o al sur.
+   if (ns)
+   {
+      // Copia la zona rectangular.
+      blit(door, top, 0, 0, 0, 0, top->w, dm.lintelHeight + dm.lintelWidthX);
+
+      int delta = top->w - 1;
+      int noPixelIndex = top->w - ((dm.rightJambWidthX + dm.rightJambWidthY) << 1) + 1;
+      int yStart = noPixelIndex;
+      int yEnd = noPixelIndex - 1;
+
+      acquire_bitmap(top);
+
+      for (int x = dm.lintelHeight + dm.lintelWidthX; x < top->h; x++)
       {
-        if(x != dm.lintelHeight + dm.lintelWidthX && y == noPixelIndex)
-        {
-          if(noPixelIndex > yEnd)
-          {
-            noPixelIndex--;
-          }
-          else
-          {
-            yStart += 2;
-            noPixelIndex = yStart;
-          }
-        }
-        else if(x < dm.lintelHeight + (dm.lintelWidthX << 1) || y < yEnd)
-        {
-          ((int*)top->line[x])[y] = ((int*)door->line[x])[y];
-        }
-      }
+         for (int y = delta; y >= 0; y--)
+         {
+            if (x != dm.lintelHeight + dm.lintelWidthX && y == noPixelIndex)
+            {
+               if (noPixelIndex > yEnd)
+               {
+                  noPixelIndex--;
+               }
+               else
+               {
+                  yStart += 2;
+                  noPixelIndex = yStart;
+               }
+            }
+            else if (x < dm.lintelHeight + (dm.lintelWidthX << 1) || y < yEnd)
+            {
+               ((int*) top->line[x])[y] = ((int*) door->line[x])[y];
+            }
+         }
 
-      delta -= 2;
-    }
+         delta -= 2;
+      }
 
-    release_bitmap(top);
-  }
-  else
-  // Copia la zona a recortar si la puerta está orientada al este o al oeste.
-  {
-    // Copia la zona rectangular.
-    blit(door, top, 0, 0, 0, 0, top->w, dm.lintelHeight + dm.lintelWidthY);
+      release_bitmap(top);
+   }
+   // Copia la zona a recortar si la puerta está orientada al este o al oeste.
+   else
+   {
+      // Copia la zona rectangular.
+      blit(door, top, 0, 0, 0, 0, top->w, dm.lintelHeight + dm.lintelWidthY);
 
-    int delta = 0;
-    int noPixelIndex = ((dm.leftJambWidthX + dm.leftJambWidthY) << 1) - 2;
-    int yStart = noPixelIndex;
-    int yEnd = noPixelIndex + 1;
+      int delta = 0;
+      int noPixelIndex = ((dm.leftJambWidthX + dm.leftJambWidthY) << 1) - 2;
+      int yStart = noPixelIndex;
+      int yEnd = noPixelIndex + 1;
 
-    acquire_bitmap(top);
+      acquire_bitmap(top);
 
-    for(int x = dm.lintelHeight + dm.lintelWidthY; x < top->h; x++)
-    {
-      for(int y = delta; y < top->w; y++)
+      for (int x = dm.lintelHeight + dm.lintelWidthY; x < top->h; x++)
       {
-        if(x != dm.lintelHeight + dm.lintelWidthY && y == noPixelIndex)
-        {
-          if(noPixelIndex < yEnd)
-          {
-            noPixelIndex++;
-          }
-          else
-          {
-            yStart -= 2;
-            noPixelIndex = yStart;
-          }
-        }
-        else if(x < dm.lintelHeight + (dm.lintelWidthY << 1) || y > yEnd)
-        {
-          ((int*)top->line[x])[y] = ((int*)door->line[x])[y];
-        }
-      }
+         for (int y = delta; y < top->w; y++)
+         {
+            if (x != dm.lintelHeight + dm.lintelWidthY && y == noPixelIndex)
+            {
+               if (noPixelIndex < yEnd)
+               {
+                  noPixelIndex++;
+               }
+               else
+               {
+                  yStart -= 2;
+                  noPixelIndex = yStart;
+               }
+            }
+            else if (x < dm.lintelHeight + (dm.lintelWidthY << 1) || y > yEnd)
+            {
+               ((int*) top->line[x])[y] = ((int*) door->line[x])[y];
+            }
+         }
 
-      delta += 2;
-    }
+         delta += 2;
+      }
 
-    release_bitmap(top);
-  }
+      release_bitmap(top);
+   }
   
-  return top;
+   return top;
 }
 
-//--------------------------------------------------------------------------------------------------
-BITMAP* ItemDataManager::cutOutLeftJamb(BITMAP* door, const DoorMeasures& dm, const ixml::door::value type)
+BITMAP* ItemDataManager::cutOutLeftJamb(BITMAP* door, const DoorMeasures& dm, const std::string& type)
 {
-  bool ns = (type == ixml::door::north || type == ixml::door::south);
-  int fixWidth = (ns ? 7 : 0);
-  int fixY = (ns ? -1 : 0);
+   bool ns{type == "north" || type == "south"};
+   int fixWidth = (ns ? 7 : 0);
+   int fixY = (ns ? -1 : 0);
   
-  BITMAP* left = create_bitmap_ex(32, (dm.leftJambWidthX << 1) + fixWidth + (dm.leftJambWidthY << 1), 
-                                       dm.leftJambHeight + dm.leftJambWidthY + dm.leftJambWidthX);
+   BITMAP* left = create_bitmap_ex(32, (dm.leftJambWidthX << 1) + fixWidth + (dm.leftJambWidthY << 1),
+                                        dm.leftJambHeight + dm.leftJambWidthY + dm.leftJambWidthX);
   
-  // El color de fondo es magenta.
-  clear_to_color(left, makecol(255, 0, 255));
-  // Copia la zona rectangular.
-  blit(door, left, fixY, dm.lintelHeight + dm.lintelWidthY - dm.leftJambWidthY + fixY, 0, 0, left->w, left->h);
+   // El color de fondo es magenta.
+   clear_to_color(left, makecol(255, 0, 255));
+   // Copia la zona rectangular.
+   blit(door, left,
+        fixY, dm.lintelHeight + dm.lintelWidthY - dm.leftJambWidthY + fixY,
+        0, 0,
+        left->w, left->h);
           
-  return left;
+   return left;
 }
 
-//--------------------------------------------------------------------------------------------------
-BITMAP* ItemDataManager::cutOutRightJamb(BITMAP* door, const DoorMeasures& dm, const ixml::door::value type)
+BITMAP* ItemDataManager::cutOutRightJamb(BITMAP* door, const DoorMeasures& dm, const std::string& type)
 {
-  bool ns = (type == ixml::door::north || type == ixml::door::south);
-  int fixWidth = (ns ? 0 : 7);
-  int fixY = (ns ? 0 : -2);
+   bool ns{type == "north" || type == "south"};
+   int fixWidth = (ns ? 0 : 7);
+   int fixY = (ns ? 0 : -2);
   
-  BITMAP* right = create_bitmap_ex(32, (dm.rightJambWidthX << 1) + fixWidth + (dm.rightJambWidthY << 1), 
-                                        dm.rightJambHeight + dm.rightJambWidthY + dm.rightJambWidthX);
+   BITMAP* right = create_bitmap_ex(32, (dm.rightJambWidthX << 1) + fixWidth + (dm.rightJambWidthY << 1),
+                                         dm.rightJambHeight + dm.rightJambWidthY + dm.rightJambWidthX);
   
-  // El color de fondo es magenta.
-  clear_to_color(right, makecol(255, 0, 255));
-  // Copia la zona rectangular.
-  blit(door, right, door->w - right->w, dm.lintelHeight + dm.lintelWidthX - dm.rightJambWidthY + fixY, 0, 0, right->w, right->h);
+   // El color de fondo es magenta.
+   clear_to_color(right, makecol(255, 0, 255));
+   // Copia la zona rectangular.
+   blit(door, right,
+        door->w - right->w,
+        dm.lintelHeight + dm.lintelWidthX - dm.rightJambWidthY + fixY,
+        0, 0,
+        right->w, right->h);
   
-  return right;
+   return right;
 }
 
-//--------------------------------------------------------------------------------------------------
 void ItemDataManager::destroyItemData(ItemData& itemData)
 {
-  itemData.bitmap.clear();
-  itemData.shadow.clear();
-  itemData.frames.clear();
-  std::for_each(itemData.motion.begin(), itemData.motion.end(), destroy_bitmap);
-  std::for_each(itemData.shadows.begin(), itemData.shadows.end(), destroy_bitmap);
-}
-
-//--------------------------------------------------------------------------------------------------
-bool EqualItemData::operator()(const ItemData& itemData, short label) const
-{
-  return (itemData.label == label);
+   itemData.bitmap.clear();
+   itemData.shadow.clear();
+   itemData.frames.clear();
+   std::for_each(itemData.motion.begin(), itemData.motion.end(), destroy_bitmap);
+   std::for_each(itemData.shadows.begin(), itemData.shadows.end(), destroy_bitmap);
 }
 
 }
diff --git a/src/ItemDataManager.hpp b/src/ItemDataManager.hpp
index 8a78ad7..f81705d 100644
--- a/src/ItemDataManager.hpp
+++ b/src/ItemDataManager.hpp
@@ -1,35 +1,33 @@
-//-------------------------------------------------------------------------
-// Head over Heels (A remake by helmántika.org)
+//--------------------------------------------------------------------------------------------------
+// Head over Heels
 //
-// © Copyright 2008 Jorge Rodríguez Santos <jorge@helmantika.org>
+// © Copyright 2008 Jorge Rodríguez Santos <jorge@helmantika.com> (This remake)
 // © Copyright 1987 Ocean Software Ltd. (Original game)
 //
-// This program is free software; you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation; either version 2 of the License, or
-// (at your option) any later version.
+// This program is free software; you can redistribute it and/or modify it under the terms of the
+// GNU General Public License as published by the Free Software Foundation; either version 2 of the
+// License, or (at your option) any later version.
 //
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 // GNU General Public License for more details.
 //
-// You should have received a copy of the GNU General Public License along
-// with this program; if not, write to the Free Software Foundation, Inc.,
-// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-//-------------------------------------------------------------------------
+// You should have received a copy of the GNU General Public License along with this program;
+// if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+// Boston, MA 02110-1301 USA.
+//--------------------------------------------------------------------------------------------------
 
 #ifndef ITEMDATAMANAGER_HPP_
 #define ITEMDATAMANAGER_HPP_
 
 #include <string>
-#include <list>
+#include <vector>
 #include <algorithm>
 #include <iostream>
 #include <functional>
+#include <boost/property_tree/xml_parser.hpp>
 #include <allegro.h>
 #include "ItemData.hpp"
-#include "csxml/ItemsXML.hpp"
 
 namespace isomot
 {
@@ -59,90 +57,101 @@ public:
 	 * definición de elementos.
 	 */
 	void load();
-	
+
 	/**
 	 * Busca un elemento en la lista.
 	 * @param label El identificador del elemento a encontrar.
 	 * @return Un registro con los datos del elemento ó 0 si la búsqueda fracasó.
 	 */
-	ItemData* find(const short label);
-  
-protected:
-  
-  /**
-   * Extracción de los fotogramas de un elemento a partir de una imagen.
-   * @param itemData Un elemento con los campos bitmap, frameWidth y frameHeight no nulos.
-   * @return El elemento con el campo motion almacenando los fotogramas ó 0 si se produjo un error.
-   */
-  ItemData* createBitmapFrames(ItemData* itemData);
-  
-  /**
-   * Extracción de los fotogramas de las sombras de un elemento a partir de una imagen.
-   * @param itemData Un elemento con los campos shadow, shadowWidth y shadowHeight no nulos.
-   * @return El elemento con el campo motion almacenando los fotogramas ó 0 si se produjo un error.
-   */
-  ItemData* createShadowFrames(ItemData* itemData);
-  
+	ItemData* find(short label);
+
 private:
   
   /**
    * Dimensiones de las partes de una puerta.
    */
-  class DoorMeasures
+  struct DoorMeasures
   {
-  public:
-   
-    /**
-     * Constructor. Inicializa todos los campos del registro de datos.
-     */
-    DoorMeasures();
-    
     /**
      * Anchura espacial del dintel en el eje X.
      */
-    int lintelWidthX;
+    int lintelWidthX{};
     
     /**
      * Anchura espacial del dintel en el eje Y.
      */
-    int lintelWidthY;
+    int lintelWidthY{};
     
     /**
      * Altura espacial del dintel.
      */    
-    int lintelHeight;
+    int lintelHeight{};
     
     /**
      * Anchura espacial de la jamba izquierda en el eje X.
      */
-    int leftJambWidthX;
+    int leftJambWidthX{};
     
     /**
      * Anchura espacial de la jamba izquierda en el eje Y.
      */
-    int leftJambWidthY;
+    int leftJambWidthY{};
     
     /**
      * Altura espacial de la jamba izquierda.
      */    
-    int leftJambHeight;
+    int leftJambHeight{};
 
     /**
      * Anchura espacial de la jamba derecha en el eje X.
      */
-    int rightJambWidthX;
+    int rightJambWidthX{};
     
     /**
      * Anchura espacial de la jamba derecha en el eje Y.
      */
-    int rightJambWidthY;
+    int rightJambWidthY{};
     
     /**
      * Altura espacial de la jamba derecha.
      */    
-    int rightJambHeight;    
+    int rightJambHeight{};
   };
   
+  /**
+   * Extracción de los fotogramas de un elemento a partir de una imagen.
+   * @param itemData Un elemento con los campos bitmap, frameWidth y frameHeight no nulos.
+   * @return El elemento con el campo motion almacenando los fotogramas ó 0 si se produjo un error.
+   */
+  void createBitmapFrames(ItemData& itemData);
+
+  /**
+   * Extracción de los fotogramas de las sombras de un elemento a partir de una imagen.
+   * @param itemData Un elemento con los campos shadow, shadowWidth y shadowHeight no nulos.
+   * @return El elemento con el campo motion almacenando los fotogramas ó 0 si se produjo un error.
+   */
+  void createShadowFrames(ItemData& itemData);
+
+  /**
+   * Lectura de los datos de un elemento.
+   * @param item Un elemento item del archivo XML.
+   */
+  void processItem(const boost::property_tree::ptree& item);
+
+  /**
+   * Lectura de los datos y creación de la sombra de un elemento.
+   * @param item Un elemento item del archivo XML.
+   * @param itemData El elemento al que se añadirá la sombra.
+   */
+  void processShadow(const boost::property_tree::ptree& item, ItemData& itemData);
+
+  /**
+   * Lectura de los datos y creación de los tres elementos de una puerta.
+   * @param item Un elemento item del archivo XML.
+   * @param itemData El elemento a partir del cual se crearán los tres elementos de la puerta.
+   */
+  void processDoor(const boost::property_tree::ptree& item, const ItemData& itemData);
+
   /**
    * Extrae el dintel de una puerta.
    * @param door Un gráfico con una puerta al completo.
@@ -150,7 +159,7 @@ private:
    * @param type Punto cardinal al que está orientado el vano de la puerta.
    * @return Un gráfico con el dintel de la puerta ó 0 si se produjo algún error.
    */
-  BITMAP* cutOutLintel(BITMAP* door, const DoorMeasures& dm, const ixml::door::value type);
+  BITMAP* cutOutLintel(BITMAP* door, const DoorMeasures& dm, const std::string& type);
   
   /**
    * Extrae la jamba izquierda de una puerta.
@@ -159,7 +168,7 @@ private:
    * @param type Punto cardinal al que está orientado el vano de la puerta.
    * @return Un gráfico con la jamba izquierda de la puerta ó 0 si se produjo algún error.
    */
-  BITMAP* cutOutLeftJamb(BITMAP* door, const DoorMeasures& dm, const ixml::door::value type);
+  BITMAP* cutOutLeftJamb(BITMAP* door, const DoorMeasures& dm, const std::string& type);
   
   /**
    * Extrae la jamba derecha de una puerta.
@@ -168,7 +177,7 @@ private:
    * @param type Punto cardinal al que está orientado el vano de la puerta.
    * @return Un gráfico con la jamba derecha de la puerta ó 0 si se produjo algún error.
    */
-  BITMAP* cutOutRightJamb(BITMAP* door, const DoorMeasures& dm, const ixml::door::value type);
+  BITMAP* cutOutRightJamb(BITMAP* door, const DoorMeasures& dm, const std::string& type);
   
   /**
    * Predicado unario de std::for_each para la destrucción de un elemento.
@@ -176,7 +185,7 @@ private:
    */
   static void destroyItemData(ItemData& itemData);
   
-protected:
+private:
 
   /**
    * Nombre del archivo XML que contiene los datos de los elementos.
@@ -186,15 +195,7 @@ protected:
   /**
    * Datos de todos los elementos del juego.
    */
-  std::list<ItemData> itemData;
-};
-
-/**
- * Objeto-función usado como predicado en la búsqueda de los datos de un elemento del juego.
- */
-struct EqualItemData : public std::binary_function<ItemData, short, bool>
-{
-  bool operator()(const ItemData& itemData, short label) const;
+  std::vector<ItemData> itemDataVector;
 };
 
 }
diff --git a/src/Makefile.am b/src/Makefile.am
index 3508a59..3122abf 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -1,11 +1,7 @@
-AUTOMAKE_OPTIONS = -Wno-override
-AM_CCFLAGS = -Wall -O2
-CXXFLAGS =
-AM_CXXFLAGS = $(CXXFLAGS)
-headoverheels_CXXFLAGS = -Wall -Wno-deprecated -O2 -I. -Iactions -Ibehaviors -Igui -Istates
-AM_LDFLAGS = `allegro-config --libs release` -lvorbisfile -lvorbisenc -lvorbis -logg -lxerces-c -lpthread
-
 bin_PROGRAMS = headoverheels
+headoverheels_CXXFLAGS = -DDEPLOY -std=c++17 -Wall -Wno-deprecated -g0 -O2 -I. -Iactions -Ibehaviors -Igui -Istates
+headoverheels_LDADD = -lalleg -lvorbisfile -lvorbisenc -lvorbis -logg
+headoverheels_LDFLAGS = -pthread
 headoverheels_SOURCES = main.cpp \
 			BonusManager.cpp \
 			BonusManager.hpp \
@@ -154,20 +150,6 @@ headoverheels_SOURCES = main.cpp \
 			behaviors/UserControlled.hpp \
 			behaviors/Volatile.cpp \
 			behaviors/Volatile.hpp \
-			csxml/ConfigurationXML.cpp \
-			csxml/ConfigurationXML.hpp \
-			csxml/ItemsXML.cpp \
-			csxml/ItemsXML.hpp \
-			csxml/LanguageXML.cpp \
-			csxml/LanguageXML.hpp \
-			csxml/MapXML.cpp \
-			csxml/MapXML.hpp \
-			csxml/RoomXML.cpp \
-			csxml/RoomXML.hpp \
-			csxml/SaveGameXML.cpp \
-			csxml/SaveGameXML.hpp \
-			csxml/SoundsXML.cpp \
-			csxml/SoundsXML.hpp \
 			gui/ConfigurationManager.cpp \
 			gui/ConfigurationManager.hpp \
 			gui/Font.cpp \
@@ -201,4 +183,4 @@ headoverheels_SOURCES = main.cpp \
 			states/JumpState.cpp \
 			states/JumpState.hpp \
 			states/MoveState.cpp \
-			states/MoveState.hpp
\ No newline at end of file
+			states/MoveState.hpp
diff --git a/src/MapManager.cpp b/src/MapManager.cpp
index 605210e..71994ba 100644
--- a/src/MapManager.cpp
+++ b/src/MapManager.cpp
@@ -16,339 +16,339 @@
 namespace isomot
 {
 
-//--------------------------------------------------------------------------------------------------
 MapManager::MapManager(Isomot* isomot, const std::string& fileName)
-: isomot(isomot),
-  activeRoom(0),
-  fileName(fileName)
-{
-  path = isomot::sharePath() + "map/";
-}
-
-//--------------------------------------------------------------------------------------------------
-MapManager::~MapManager()
+   :
+   isomot{isomot},
+   activeRoom{},
+   fileName{fileName}
 {
-
+   path = isomot::sharePath() + "map/";
 }
 
-//--------------------------------------------------------------------------------------------------
 void MapManager::load()
 {
-  // Carga el archivo XML especificado y almacena los datos XML en la lista.
-  try
-  {
-    std::auto_ptr<mxml::MapXML> mapXML(mxml::map((path + fileName).c_str()));
-
-    for(mxml::MapXML::room_const_iterator i = mapXML->room().begin(); i != mapXML->room().end (); ++i)
-    {
-      // Se crea la sala a partir del nombre de su archivo XML.
-      std::auto_ptr<MapRoomData> roomData(new MapRoomData((*i).file()));
-
-      // Conexión norte.
-      if((*i).north().present())
-      {
-        roomData->setNorth((*i).north().get());
-      }
-
-      // Conexión sur.
-      if((*i).south().present())
-      {
-        roomData->setSouth((*i).south().get());
-      }
-
-      // Conexión este.
-      if((*i).east().present())
-      {
-        roomData->setEast((*i).east().get());
-      }
-
-      // Conexión oeste.
-      if((*i).west().present())
-      {
-        roomData->setWest((*i).west().get());
-      }
-
-      // Conexión inferior.
-      if((*i).floor().present())
-      {
-        roomData->setFloor((*i).floor().get());
-      }
-
-      // Conexión superior.
-      if((*i).roof().present())
-      {
-        roomData->setRoof((*i).roof().get());
-      }
-
-      // Conexión por telepuerto.
-      if((*i).teleport().present())
-      {
-        roomData->setTeleport((*i).teleport().get());
-      }
-
-      // Conexión por un segundo telepuerto.
-      if((*i).teleport2().present())
-      {
-        roomData->setTeleport2((*i).teleport2().get());
-      }
-
-      // Conexión norte-este.
-      if((*i).north_east().present())
-      {
-        roomData->setNorthEast((*i).north_east().get());
-      }
-
-      // Conexión norte-oeste.
-      if((*i).north_west().present())
-      {
-        roomData->setNorthWest((*i).north_west().get());
-      }
-
-      // Conexión sur-este.
-      if((*i).south_east().present())
+   // Carga el archivo XML especificado y almacena los datos XML en la lista.
+   try
+   {
+      boost::property_tree::ptree xmlTree;
+      boost::property_tree::xml_parser::read_xml(path + fileName, xmlTree);
+
+      auto&& roomIter = xmlTree.get_child("map").equal_range("room");
+      for (auto&& i = roomIter.first; i != roomIter.second; ++i)
       {
-        roomData->setSouthEast((*i).south_east().get());
-      }
-
-      // Conexión norte-oeste.
-      if((*i).south_west().present())
-      {
-        roomData->setSouthWest((*i).south_west().get());
+         // Se crea la sala a partir del nombre de su archivo XML.
+         std::unique_ptr<MapRoomData> roomData(new MapRoomData(i->second.get<std::string>("<xmlattr>.file")));
+
+         // Conexión norte.
+         if (std::string way{i->second.get<std::string>("north", "")}; !way.empty())
+         {
+            roomData->setNorth(way);
+         }
+
+         // Conexión sur.
+         if (std::string way{i->second.get<std::string>("south", "")}; !way.empty())
+         {
+            roomData->setSouth(way);
+         }
+
+         // Conexión este.
+         if (std::string way{i->second.get<std::string>("east", "")}; !way.empty())
+         {
+            roomData->setEast(way);
+         }
+
+         // Conexión oeste.
+         if (std::string way{i->second.get<std::string>("west", "")}; !way.empty())
+         {
+            roomData->setWest(way);
+         }
+
+         // Conexión inferior.
+         if (std::string way{i->second.get<std::string>("floor", "")}; !way.empty())
+         {
+            roomData->setFloor(way);
+         }
+
+         // Conexión superior.
+         if (std::string way{i->second.get<std::string>("roof", "")}; !way.empty())
+         {
+            roomData->setRoof(way);
+         }
+
+         // Conexión por telepuerto.
+         if (std::string way{i->second.get<std::string>("teleport", "")}; !way.empty())
+         {
+            roomData->setTeleport(way);
+         }
+
+         // Conexión por un segundo telepuerto.
+         if (std::string way{i->second.get<std::string>("teleport2", "")}; !way.empty())
+         {
+            roomData->setTeleport2(way);
+         }
+
+         // Conexión norte-este.
+         if (std::string way{i->second.get<std::string>("north-east", "")}; !way.empty())
+         {
+            roomData->setNorthEast(way);
+         }
+
+         // Conexión norte-oeste.
+         if (std::string way{i->second.get<std::string>("north-west", "")}; !way.empty())
+         {
+            roomData->setNorthWest(way);
+         }
+
+         // Conexión sur-este.
+         if (std::string way{i->second.get<std::string>("south-east", "")}; !way.empty())
+         {
+            roomData->setSouthEast(way);
+         }
+
+         // Conexión sur-oeste.
+         if (std::string way{i->second.get<std::string>("south-west", "")}; !way.empty())
+         {
+            roomData->setSouthWest(way);
+         }
+
+         // Conexión este-norte.
+         if (std::string way{i->second.get<std::string>("east-north", "")}; !way.empty())
+         {
+            roomData->setEastNorth(way);
+         }
+
+         // Conexión este-sur.
+         if (std::string way{i->second.get<std::string>("east-south", "")}; !way.empty())
+         {
+            roomData->setEastSouth(way);
+         }
+
+         // Conexión oeste-norte.
+         if (std::string way{i->second.get<std::string>("west-north", "")}; !way.empty())
+         {
+            roomData->setWestNorth(way);
+         }
+
+         // Conexión oeste-sur.
+         if (std::string way{i->second.get<std::string>("west-south", "")}; !way.empty())
+         {
+            roomData->setWestSouth(way);
+         }
+
+         // Los datos de la sala se incorporan a la lista.
+         this->mapData.push_back(*roomData.get());
       }
+   }
+   catch (const std::runtime_error& e)
+   {
+      std::cerr << e.what() << std::endl;
+   }
+}
 
-      // Conexión este-norte.
-      if((*i).east_north().present())
+void MapManager::start(const std::string& firstRoomFileName, const std::string& secondRoomFileName)
+{
+   // Datos de la primera sala en el mapa.
+   MapRoomData* firstRoomData = findRoomData(firstRoomFileName);
+
+   // Creación de la primera sala.
+   if(firstRoomData != 0)
+   {
+      std::unique_ptr<RoomBuilder> roomBuilder(new RoomBuilder(isomot->getItemDataManager(),
+                                                               path + firstRoomFileName));
+      Room* firstRoom = roomBuilder->buildRoom();
+
+      // Si se ha creado la sala se coloca al primer personaje en el centro.
+      if(firstRoom != 0)
       {
-        roomData->setEastNorth((*i).east_north().get());
+         // Posición inicial del jugador.
+         ItemData* firstPlayerData = isomot->getItemDataManager()->find(Head);
+
+         int centerX = ((firstRoom->getBound(South) - firstRoom->getBound(North) + firstPlayerData->widthX) >>1) +
+                        (firstRoom->getDoor(North) != 0 ? firstRoom->getTileSize() >> 1 : 0) -
+                        (firstRoom->getDoor(South) != 0 ? firstRoom->getTileSize() >> 1 : 0);
+         int centerY = ((firstRoom->getBound(West) - firstRoom->getBound(East) + firstPlayerData->widthY) >> 1) +
+                        (firstRoom->getDoor(East) != 0 ? firstRoom->getTileSize() >> 1 : 0) -
+                        (firstRoom->getDoor(West) != 0 ? firstRoom->getTileSize() >> 1 : 0) - 1;
+
+         // Almacena en los datos de la sala en el mapa la posición inicial del jugador.
+         PlayerStartPosition firstPlayerPosition(Head);
+         firstPlayerPosition.assignPosition(Wait, centerX, centerY, 0, West);
+         firstRoomData->addPlayerPosition(firstPlayerPosition);
+
+         // Crea al jugador.
+         roomBuilder->buildPlayerItem(Head, HeadBehavior, centerX, centerY, 0, West);
+
+         // La primera sala es la sala activa.
+         firstRoom->activatePlayer(Head);
+         firstRoom->getCamera()->turnOn(firstRoom->getMediator()->getActivePlayer(), Wait);
+         activeRoom = firstRoom;
+         firstRoomData->setActivePlayer(Head);
+         rooms.push_back(firstRoom);
       }
+   }
 
-      // Conexión este-sur.
-      if((*i).east_south().present())
-      {
-        roomData->setEastSouth((*i).east_south().get());
-      }
+   // Datos de la segunda sala en el mapa.
+   MapRoomData* secondRoomData = findRoomData(secondRoomFileName);
 
-      // Conexión oeste-norte.
-      if((*i).west_north().present())
-      {
-        roomData->setWestNorth((*i).west_north().get());
-      }
+   // Creación de la segunda sala.
+   if(secondRoomData != 0)
+   {
+      std::unique_ptr<RoomBuilder> roomBuilder(new RoomBuilder(isomot->getItemDataManager(),
+                                                               path + secondRoomFileName));
+      Room* secondRoom = roomBuilder->buildRoom();
 
-      // Conexión oeste-sur.
-      if((*i).west_south().present())
+      // Si se ha creado la sala se coloca al primer personaje en el centro.
+      if(secondRoom != 0)
       {
-        roomData->setWestSouth((*i).west_south().get());
+         // Posición inicial del jugador.
+         ItemData* secondPlayerData = isomot->getItemDataManager()->find(Heels);
+
+         int centerX = ((secondRoom->getBound(South) - secondRoom->getBound(North) + secondPlayerData->widthX) >> 1) +
+                        (secondRoom->getDoor(North) != 0 ? secondRoom->getTileSize() >> 1 : 0) -
+                        (secondRoom->getDoor(South) != 0 ? secondRoom->getTileSize() >> 1 : 0);
+         int centerY = ((secondRoom->getBound(West) - secondRoom->getBound(East) + secondPlayerData->widthY) >> 1) +
+                        (secondRoom->getDoor(East) != 0 ? secondRoom->getTileSize() >> 1 : 0) -
+                        (secondRoom->getDoor(West) != 0 ? secondRoom->getTileSize() >> 1 : 0) - 1;
+
+         // Almacena en los datos de la sala en el mapa la posición inicial del jugador.
+         PlayerStartPosition secondPlayerPosition(Heels);
+         secondPlayerPosition.assignPosition(Wait, centerX, centerY, 0, South);
+         secondRoomData->addPlayerPosition(secondPlayerPosition);
+
+         // Crea al jugador.
+         roomBuilder->buildPlayerItem(Heels, HeelsBehavior, centerX, centerY, 0, South);
+
+         // Activa al jugador.
+         secondRoom->activatePlayer(Heels);
+         secondRoom->getCamera()->turnOn(secondRoom->getMediator()->getActivePlayer(), Wait);
+         secondRoomData->setActivePlayer(Heels);
+         rooms.push_back(secondRoom);
       }
-
-      // Los datos de la sala se incorporan a la lista.
-      this->mapData.push_back(*roomData.get());
-    }
-  }
-  catch(const xml_schema::exception& e)
-  {
-    std::cerr << e << std::endl;
-  }
-  catch(const Exception& e)
-  {
-    std::cerr << e.what() << std::endl;
-  }
+   }
 }
 
-//--------------------------------------------------------------------------------------------------
-void MapManager::start(const std::string& firstRoomFileName, const std::string& secondRoomFileName)
+void MapManager::startOldGame(const boost::property_tree::ptree& data)
 {
-  // Datos de la primera sala en el mapa.
-  MapRoomData* firstRoomData = findRoomData(firstRoomFileName);
-
-  // Creación de la primera sala.
-  if(firstRoomData != 0)
-  {
-    std::auto_ptr<RoomBuilder> roomBuilder(new RoomBuilder(isomot->getItemDataManager(), path + firstRoomFileName));
-    Room* firstRoom = roomBuilder->buildRoom();
-
-    // Si se ha creado la sala se coloca al primer personaje en el centro.
-    if(firstRoom != 0)
-    {
-      // Posición inicial del jugador.
-      ItemData* firstPlayerData = isomot->getItemDataManager()->find(Head);
-
-      int centerX = ((firstRoom->getBound(South) - firstRoom->getBound(North) + firstPlayerData->widthX) >>1) +
-                     (firstRoom->getDoor(North) != 0 ? firstRoom->getTileSize() >> 1 : 0) -
-                     (firstRoom->getDoor(South) != 0 ? firstRoom->getTileSize() >> 1 : 0);
-      int centerY = ((firstRoom->getBound(West) - firstRoom->getBound(East) + firstPlayerData->widthY) >> 1) +
-                     (firstRoom->getDoor(East) != 0 ? firstRoom->getTileSize() >> 1 : 0) -
-                     (firstRoom->getDoor(West) != 0 ? firstRoom->getTileSize() >> 1 : 0) - 1;
-
-      // Almacena en los datos de la sala en el mapa la posición inicial del jugador.
-      PlayerStartPosition firstPlayerPosition(Head);
-      firstPlayerPosition.assignPosition(Wait, centerX, centerY, 0, West);
-      firstRoomData->addPlayerPosition(firstPlayerPosition);
-
-      // Crea al jugador.
-      roomBuilder->buildPlayerItem(Head, HeadBehavior, centerX, centerY, 0, West);
-
-      // La primera sala es la sala activa.
-      firstRoom->activatePlayer(Head);
-      firstRoom->getCamera()->turnOn(firstRoom->getMediator()->getActivePlayer(), Wait);
-      activeRoom = firstRoom;
-      firstRoomData->setActivePlayer(Head);
-      rooms.push_back(firstRoom);
-    }
-  }
-
-  // Datos de la segunda sala en el mapa.
-  MapRoomData* secondRoomData = findRoomData(secondRoomFileName);
-
-  // Creación de la segunda sala.
-  if(secondRoomData != 0)
-  {
-    std::auto_ptr<RoomBuilder> roomBuilder(new RoomBuilder(isomot->getItemDataManager(), path + secondRoomFileName));
-    Room* secondRoom = roomBuilder->buildRoom();
-
-    // Si se ha creado la sala se coloca al primer personaje en el centro.
-    if(secondRoom != 0)
-    {
-      // Posición inicial del jugador.
-      ItemData* secondPlayerData = isomot->getItemDataManager()->find(Heels);
-
-      int centerX = ((secondRoom->getBound(South) - secondRoom->getBound(North) + secondPlayerData->widthX) >> 1) +
-                     (secondRoom->getDoor(North) != 0 ? secondRoom->getTileSize() >> 1 : 0) -
-                     (secondRoom->getDoor(South) != 0 ? secondRoom->getTileSize() >> 1 : 0);
-      int centerY = ((secondRoom->getBound(West) - secondRoom->getBound(East) + secondPlayerData->widthY) >> 1) +
-                     (secondRoom->getDoor(East) != 0 ? secondRoom->getTileSize() >> 1 : 0) -
-                     (secondRoom->getDoor(West) != 0 ? secondRoom->getTileSize() >> 1 : 0) - 1;
-
-      // Almacena en los datos de la sala en el mapa la posición inicial del jugador.
-      PlayerStartPosition secondPlayerPosition(Heels);
-      secondPlayerPosition.assignPosition(Wait, centerX, centerY, 0, South);
-      secondRoomData->addPlayerPosition(secondPlayerPosition);
-
-      // Crea al jugador.
-      roomBuilder->buildPlayerItem(Heels, HeelsBehavior, centerX, centerY, 0, South);
-
-      // Activa al jugador.
-      secondRoom->activatePlayer(Heels);
-      secondRoom->getCamera()->turnOn(secondRoom->getMediator()->getActivePlayer(), Wait);
-      secondRoomData->setActivePlayer(Heels);
-      rooms.push_back(secondRoom);
-    }
-  }
-}
-
-//--------------------------------------------------------------------------------------------------
-void MapManager::startOldGame(const sgxml::player& data)
-{
-  // Datos de la sala en el mapa.
-  MapRoomData* roomData = findRoomData(data.roomFilename());
-  // La sala a crear.
-  Room* room = 0;
-
-  // Creación de la sala.
-  if(roomData != 0)
-  {
-    // Si ya hay una sala creada existe la posibilidad de que la sala del segundo jugador sea la misma.
-    if(this->activeRoom != 0 && this->activeRoom->getIdentifier().compare(roomData->getRoom()) == 0)
-    {
-      room = this->activeRoom;
-    }
-    else
-    {
-      std::auto_ptr<RoomBuilder> roomBuilder(new RoomBuilder(isomot->getItemDataManager(), path + data.roomFilename()));
-      room = roomBuilder->buildRoom();
-    }
-
-    // Si se ha creado la sala se coloca al personaje.
-    if(room != 0)
-    {
-      PlayerId playerId;
-      BehaviorId behaviorId;
-
-      switch(data.label())
+   // Datos de la sala en el mapa.
+   MapRoomData* roomData = findRoomData(data.get<std::string>("roomFilename"));
+   // La sala a crear.
+   Room* room = 0;
+
+   // Creación de la sala.
+   if(roomData != 0)
+   {
+      // Si ya hay una sala creada existe la posibilidad de que la sala del segundo jugador sea la misma.
+      if(this->activeRoom != 0 && this->activeRoom->getIdentifier().compare(roomData->getRoom()) == 0)
       {
-        case Head:
-          playerId = Head;
-          behaviorId = HeadBehavior;
-          break;
-
-        case Heels:
-          playerId = Heels;
-          behaviorId = HeelsBehavior;
-          break;
-
-        case HeadAndHeels:
-          playerId = HeadAndHeels;
-          behaviorId = HeadAndHeelsBehavior;
-          break;
+         room = this->activeRoom;
       }
-
-      // Almacena en los datos de la sala en el mapa la posición inicial del jugador.
-      PlayerStartPosition playerPosition(playerId);
-      playerPosition.assignPosition(Direction(data.entry()), data.x(), data.y(), data.z(), Direction(data.direction()));
-      roomData->addPlayerPosition(playerPosition);
-
-      // Crea al jugador en la sala.
-      std::auto_ptr<RoomBuilder> roomBuilder(new RoomBuilder(isomot->getItemDataManager()));
-      PlayerItem* player = roomBuilder->buildPlayerItem(room, playerId, behaviorId, data.x(), data.y(), data.z(), Direction(data.direction()));
-
-      // Se cambia el estado del jugador en función de la vía de entrada.
-      switch(Direction(data.entry()))
+      else
       {
-        case North:
-        case Northeast:
-        case Northwest:
-          player->getBehavior()->changeStateId(StateAutoMoveSouth);
-          break;
-
-        case South:
-        case Southeast:
-        case Southwest:
-          player->getBehavior()->changeStateId(StateAutoMoveNorth);
-          break;
-
-        case East:
-        case Eastnorth:
-        case Eastsouth:
-          player->getBehavior()->changeStateId(StateAutoMoveWest);
-          break;
-
-        case West:
-        case Westnorth:
-        case Westsouth:
-          player->getBehavior()->changeStateId(StateAutoMoveEast);
-          break;
-
-        case ByTeleport:
-        case ByTeleport2:
-        case Wait:
-          player->getBehavior()->changeStateId(StateStartWayInTeletransport);
-          break;
-
-        default:
-          ;
+         std::unique_ptr<RoomBuilder> roomBuilder(new RoomBuilder(isomot->getItemDataManager(),
+                                                                  path + data.get<std::string>("roomFilename")));
+         room = roomBuilder->buildRoom();
       }
 
-      // Si se está creando al jugador activo entonces su sala es la sala activa.
-      if(data.active())
+      // Si se ha creado la sala se coloca al personaje.
+      if(room != 0)
       {
-        room->activatePlayer(playerId);
-        room->getCamera()->turnOn(room->getMediator()->getActivePlayer(), Direction(data.entry()));
-        this->activeRoom = room;
-        roomData->setActivePlayer(playerId);
-        this->rooms.push_back(room);
+         PlayerId playerId;
+         BehaviorId behaviorId;
+
+         switch (data.get<short>("<xmlattr>.label"))
+         {
+            case Head:
+               playerId = Head;
+               behaviorId = HeadBehavior;
+               break;
+
+            case Heels:
+               playerId = Heels;
+               behaviorId = HeelsBehavior;
+               break;
+
+            case HeadAndHeels:
+               playerId = HeadAndHeels;
+               behaviorId = HeadAndHeelsBehavior;
+               break;
+         }
+
+         // Almacena en los datos de la sala en el mapa la posición inicial del jugador.
+         PlayerStartPosition playerPosition(playerId);
+         playerPosition.assignPosition(Direction(data.get<int>("entry")),
+                                       data.get<int>("x"),
+                                       data.get<int>("y"),
+                                       data.get<int>("z"),
+                                       Direction(data.get<int>("direction")));
+         roomData->addPlayerPosition(playerPosition);
+
+         // Crea al jugador en la sala.
+         std::unique_ptr<RoomBuilder> roomBuilder(new RoomBuilder(isomot->getItemDataManager()));
+         PlayerItem* player = roomBuilder->buildPlayerItem(room, playerId, behaviorId,
+                                                           data.get<int>("x"),
+                                                           data.get<int>("y"),
+                                                           data.get<int>("z"),
+                                                           Direction(data.get<int>("direction")));
+
+         // Se cambia el estado del jugador en función de la vía de entrada.
+         switch(Direction(data.get<int>("entry")))
+         {
+            case North:
+            case Northeast:
+            case Northwest:
+               player->getBehavior()->changeStateId( StateAutoMoveSouth );
+               break;
+
+            case South:
+            case Southeast:
+            case Southwest:
+               player->getBehavior()->changeStateId( StateAutoMoveNorth );
+               break;
+
+            case East:
+            case Eastnorth:
+            case Eastsouth:
+               player->getBehavior()->changeStateId( StateAutoMoveWest );
+               break;
+
+            case West:
+            case Westnorth:
+            case Westsouth:
+               player->getBehavior()->changeStateId( StateAutoMoveEast );
+               break;
+
+            case ByTeleport:
+            case ByTeleport2:
+            case Wait:
+               player->getBehavior()->changeStateId( StateStartWayInTeletransport );
+               break;
+
+            default:
+               ;
+         }
+
+         // Si se está creando al jugador activo entonces su sala es la sala activa.
+         if(data.get<bool>("active"))
+         {
+            room->activatePlayer(playerId);
+            room->getCamera()->turnOn(room->getMediator()->getActivePlayer(), Direction(data.get<int>("entry")));
+            this->activeRoom = room;
+            roomData->setActivePlayer(playerId);
+            this->rooms.push_back(room);
+         }
+         // Si el otro jugador se crea en otra sala entonces se establece como el jugador
+         // que el usuario controla en dicha sala. Si se crea en la misma sala que el
+         // jugador activo entonces no hace falta hacer nada más.
+         else if(this->activeRoom != room)
+         {
+            // Activa al jugador.
+            room->activatePlayer(playerId);
+            room->getCamera()->turnOn(room->getMediator()->getActivePlayer(), Direction(data.get<int>("entry")));
+            roomData->setActivePlayer(playerId);
+            this->rooms.push_back(room);
+         }
       }
-      // Si el otro jugador se crea en otra sala entonces se establece como el jugador
-      // que el usuario controla en dicha sala. Si se crea en la misma sala que el
-      // jugador activo entonces no hace falta hacer nada más.
-      else if(this->activeRoom != room)
-      {
-        // Activa al jugador.
-        room->activatePlayer(playerId);
-        room->getCamera()->turnOn(room->getMediator()->getActivePlayer(), Direction(data.entry()));
-        roomData->setActivePlayer(playerId);
-        this->rooms.push_back(room);
-      }
-    }
-  }
+   }
 }
 
 //--------------------------------------------------------------------------------------------------
@@ -431,7 +431,7 @@ Room* MapManager::changeRoom(const Direction& exit)
   // Si la sala no está creada entonces se crea.
   if(!destinationRoomData->remainPlayers())
   {
-    std::auto_ptr<RoomBuilder> roomBuilder(new RoomBuilder(isomot->getItemDataManager(), path + destinationRoomData->getRoom()));
+    std::unique_ptr<RoomBuilder> roomBuilder(new RoomBuilder(isomot->getItemDataManager(), path + destinationRoomData->getRoom()));
     newRoom = roomBuilder->buildRoom();
     rooms.push_back(newRoom);
   }
@@ -471,7 +471,7 @@ Room* MapManager::changeRoom(const Direction& exit)
   }
 
   // Crea al jugador.
-  std::auto_ptr<RoomBuilder> roomBuilder(new RoomBuilder(isomot->getItemDataManager()));
+  std::unique_ptr<RoomBuilder> roomBuilder(new RoomBuilder(isomot->getItemDataManager()));
   if(entry == ByTeleport || entry == ByTeleport2)
   {
     z = Top;
@@ -544,7 +544,7 @@ Room* MapManager::restartRoom()
   MapRoomData* activeRoomData = findRoomData(activeRoom->getIdentifier());
 
   // Se vuelve a crear la sala.
-  std::auto_ptr<RoomBuilder> roomBuilder(new RoomBuilder(isomot->getItemDataManager(), path + activeRoomData->getRoom()));
+  std::unique_ptr<RoomBuilder> roomBuilder(new RoomBuilder(isomot->getItemDataManager(), path + activeRoomData->getRoom()));
   newRoom = roomBuilder->buildRoom();
 
   // Posición inicial de todos los jugadores presentes en la sala.
@@ -732,7 +732,7 @@ Room* MapManager::restartRoom()
 //--------------------------------------------------------------------------------------------------
 Room* MapManager::createRoom(const std::string& fileName)
 {
-  std::auto_ptr<RoomBuilder> roomBuilder(new RoomBuilder(isomot->getItemDataManager(), path + fileName));
+  std::unique_ptr<RoomBuilder> roomBuilder(new RoomBuilder(isomot->getItemDataManager(), path + fileName));
   return roomBuilder->buildRoom();
 }
 
@@ -810,28 +810,35 @@ void MapManager::updateActivePlayer()
 }
 
 //--------------------------------------------------------------------------------------------------
-void MapManager::load(sgxml::exploredRooms::visited_sequence& visitedSequence)
+void MapManager::load(boost::property_tree::ptree& visitedSequence)
 {
-  for(sgxml::exploredRooms::visited_const_iterator i = visitedSequence.begin(); i != visitedSequence.end(); ++i)
-  {
-    std::list<MapRoomData>::iterator m = std::find_if(mapData.begin(), mapData.end(), std::bind2nd(EqualMapRoomData(), (*i).filename()));
-    if(m != mapData.end())
-    {
-      static_cast<MapRoomData*>(&(*m))->setVisited(true);
-    }
-  }
+   auto&& roomIter = visitedSequence.equal_range("visited");
+   for (auto&& i = roomIter.first; i != roomIter.second; ++i)
+   {
+      std::list<MapRoomData>::iterator m = std::find_if(mapData.begin(), mapData.end(),
+                                                        std::bind2nd(EqualMapRoomData(),
+                                                                     i->second.get<std::string>("<xmlattr>.filename")));
+      if (m != mapData.end())
+      {
+         static_cast<MapRoomData*>(&(*m))->setVisited(true);
+      }
+   }
 }
 
 //--------------------------------------------------------------------------------------------------
-void MapManager::save(sgxml::exploredRooms::visited_sequence& visitedSequence)
+void MapManager::save(boost::property_tree::ptree& visitedSequence)
 {
-  for(std::list<MapRoomData>::iterator i = this->mapData.begin(); i != this->mapData.end(); ++i)
-  {
-    if((*i).isVisited())
-    {
-      visitedSequence.push_back(sgxml::visited((*i).getRoom()));
-    }
-  }
+   boost::property_tree::ptree exploredRooms;
+   for (std::list<MapRoomData>::iterator i = this->mapData.begin(); i != this->mapData.end(); ++i)
+   {
+      if ((*i).isVisited())
+      {
+         boost::property_tree::ptree xmlTree;
+         xmlTree.put("<xmlattr>.filename", (*i).getRoom());
+         exploredRooms.add_child("visited", xmlTree);
+      }
+   }
+   visitedSequence.add_child("savegame.exploredRooms", exploredRooms);
 }
 
 //--------------------------------------------------------------------------------------------------
diff --git a/src/MapManager.hpp b/src/MapManager.hpp
index e159dbf..2ad4c66 100644
--- a/src/MapManager.hpp
+++ b/src/MapManager.hpp
@@ -29,8 +29,7 @@
 #include <functional>
 #include <allegro.h>
 #include "MapRoomData.hpp"
-#include "csxml/MapXML.hpp"
-#include "csxml/SaveGameXML.hpp"
+#include <boost/property_tree/ptree.hpp>
 
 namespace isomot
 {
@@ -56,7 +55,7 @@ public:
   /**
    * Destructor.
    */
-	virtual ~MapManager();
+	virtual ~MapManager() {}
 	
   /**
    * Crea la lista de datos a partir de la información extraída por el gestor XML del archivo del mapa. 
@@ -71,82 +70,82 @@ public:
    * del juego, aquella donde se colocará al segundo jugador.
    */
   virtual void start(const std::string& firstRoomFileName, const std::string& secondRoomFileName);
-  
+
   /**
    * Crea la sala inicial de un jugador determinado.
    * @param data Datos del archivo que contiene la información de una partida guardada.
    */
-  void startOldGame(const sgxml::player& data);
-  
+  void startOldGame(const boost::property_tree::ptree& data);
+
   /**
    * Limpia los datos almacenados relacionados con la partida en curso.
    */
   void reset();
-  
+
   /**
    * Cambia la sala activa en función de la salida tomada por el jugador.
    * @param exit Salida tomada por el jugador.
    * @return La nueva sala.
    */
   Room* changeRoom(const Direction& exit);
-  
+
   /**
    * Reinicia la sala activa, es decir, se vuelve a crear la sala activa en el estado inicial.
    * @return La nueva sala.
    */
   Room* restartRoom();
-  
+
   /**
    * Construye una sala a partir de los datos de un archivo.
    * @param fileName Nombre del archivo que contiene los datos de la sala.
    * @return La sala creada ó 0 si no se pudo construir.
    */
   Room* createRoom(const std::string& fileName);
-  
+
   /**
    * Cambia la sala activa por la sala siguiente donde haya un jugador.
    */
   Room* swapRoom();
-  
+
   /**
    * Destruye la sala actual y establece como sala activa la sala donde se encuentra el
    * otro jugador. Utilizada cuando uno de los jugadores se queda sin vidas.
    */
   Room* destroyAndSwapRoom();
-  
+
   /**
-   * Actualiza el jugador activo de la sala activa. El valor se obtiene a partir de 
+   * Actualiza el jugador activo de la sala activa. El valor se obtiene a partir de
    * los datos de la sala activa.
    */
   void updateActivePlayer();
-  
+
   /**
    * Lee del disco las salas visitadas por los jugadores.
-   * @param visitedSequence Estructura de datos empleada por el archivo XML para guardar 
+   * @param visitedSequence Estructura de datos empleada por el archivo XML para guardar
    * las salas visitadas.
    */
-  void load(sgxml::exploredRooms::visited_sequence& visitedSequence);
-  
+  void load(boost::property_tree::ptree& visitedSequence);
+
   /**
    * Guarda en disco las salas visitadas por los jugadores.
-   * @param visitedSequence Estructura de datos empleada por el archivo XML para guardar 
+   * @param visitedSequence Estructura de datos empleada por el archivo XML para guardar
    * las salas visitadas.
    */
-  void save(sgxml::exploredRooms::visited_sequence& visitedSequence);
-  
+  void save(boost::property_tree::ptree& visitedSequence);
+
   /**
    * Cuenta el número de salas visitadas por los jugadores.
    * @return Un número mayor que 2.
    */
   unsigned short countVisitedRooms();
-  
+
   /**
    * Busca los datos de una sala en el mapa en la lista.
    * @param room El nombre del archivo de la sala.
    * @return Un registro con los datos de la sala en el mapa ó 0 si la búsqueda fracasó.
    */
   MapRoomData* findRoomData(const std::string& room);
-  
+
   /**
    * Busca una sala en el conjunto de salas creadas.
    * @param room El nombre del archivo de la sala.
diff --git a/src/Room.hpp b/src/Room.hpp
index 69a43be..de1a23c 100644
--- a/src/Room.hpp
+++ b/src/Room.hpp
@@ -156,7 +156,7 @@ public:
    * @param hasNorthDoor La sala tiene una puerta al norte.
    * @param hasNorthEast La sala tiene una puerta al este.
    * @param deltaX Diferencia en el eje X a aplicar para ajustar la posición de la sala en pantalla.
-   * @param deltaY Diferencia en el eje Y a aplicar para ajustar la posición de la sala en pantalla. 
+   * @param deltaY Diferencia en el eje Y a aplicar para ajustar la posición de la sala en pantalla.
    */
   void calculateCoordinates(bool hasNorthDoor, bool hasEastDoor, int deltaX, int deltaY);
   
diff --git a/src/RoomBuilder.cpp b/src/RoomBuilder.cpp
index e5029eb..ca42fb0 100644
--- a/src/RoomBuilder.cpp
+++ b/src/RoomBuilder.cpp
@@ -1,5 +1,4 @@
 #include "RoomBuilder.hpp"
-#include "Exception.hpp"
 #include "ItemDataManager.hpp"
 #include "Room.hpp"
 #include "FloorTile.hpp"
@@ -14,443 +13,517 @@
 namespace isomot
 {
 
-//--------------------------------------------------------------------------------------------------
 RoomBuilder::RoomBuilder(ItemDataManager* itemDataManager, const std::string& fileName)
+   :
+   fileName{fileName},
+   itemDataManager{itemDataManager},
+   room{},
+   directionMap{{"none", NoDirection},
+                {"south", South},
+                {"west", West},
+                {"north", North},
+                {"east", East},
+                {"northeast", Northeast},
+                {"southeast", Southeast},
+                {"southwest", Southwest},
+                {"northwest", Northwest},
+                {"eastnorth", Eastnorth},
+                {"eastsouth", Eastsouth},
+                {"westnorth", Westnorth},
+                {"westsouth", Westsouth}}
 {
-  // Nombre del archivo.
-  this->fileName = fileName;
 
-  // El gestor de datos.
-  this->itemDataManager = itemDataManager;
-  // La sala en construcción.
-  this->room = 0;
 }
 
-//--------------------------------------------------------------------------------------------------
 RoomBuilder::RoomBuilder(ItemDataManager* itemDataManager)
-{
-  // El gestor de datos.
-  this->itemDataManager = itemDataManager;
-  // La sala en construcción.
-  this->room = 0;
-}
-
-//--------------------------------------------------------------------------------------------------
-RoomBuilder::~RoomBuilder()
+   :
+   itemDataManager{itemDataManager},
+   room{},
+   directionMap{{"none", NoDirection},
+                {"south", South},
+                {"west", West},
+                {"north", North},
+                {"east", East},
+                {"northeast", Northeast},
+                {"southeast", Southeast},
+                {"southwest", Southwest},
+                {"northwest", Northwest},
+                {"eastnorth", Eastnorth},
+                {"eastsouth", Eastsouth},
+                {"westnorth", Westnorth},
+                {"westsouth", Westsouth}}
 {
 
 }
 
-//--------------------------------------------------------------------------------------------------
 Room* RoomBuilder::buildRoom()
 {
-  // Procesa el archivo XML especificado para construir la sala.
-  try
-  {
-    std::auto_ptr<rxml::RoomXML> roomXML(rxml::room(fileName.c_str()));
-
-    // Crea la sala con los parámetros básicos: identificador, dimensiones y existencia o no de suelo.
-    this->room = new Room(roomXML->name(), roomXML->scenery(), roomXML->xTiles(), roomXML->yTiles(), roomXML->width(), FloorId(int(roomXML->floorType())));
-    if(this->room == 0) throw "Room creation error: " + fileName + " has bad atributtes.";
-
-    // Para calcular las coordenadas de pantalla donde se situará el origen del espacio isométrico,
-    // se necesita saber si la sala tiene puerta al norte y/o al este.
-    bool hasNorthDoor = false;
-    bool hasEastDoor = false;
-
-    // Recorre la lista de elementos buscando las puertas.
-    for(rxml::items::item_const_iterator i = roomXML->items().item().begin(); i != roomXML->items().item().end(); ++i)
-    {
-      if((*i).type() == rxml::type::door)
-      {
-        if((*i).direction() == rxml::direction::north || (*i).direction() == rxml::direction::northeast || (*i).direction() == rxml::direction::northwest)
-        {
-          hasNorthDoor = true;
-        }
-        else if((*i).direction() == rxml::direction::east || (*i).direction() == rxml::direction::eastnorth || (*i).direction() == rxml::direction::eastsouth)
-        {
-          hasEastDoor = true;
-        }
-      }
-    }
-
-    // Una vez que se sabe de la existencia o no de las puertas, se calculan las coordenadas.
-    room->calculateCoordinates(hasNorthDoor, hasEastDoor,
-                               roomXML->deltaX().present() ? roomXML->deltaX().get() : 0,
-                               roomXML->deltaY().present() ? roomXML->deltaY().get() : 0);
-
-    // Si la sala es triple se almacenan los datos constantes para situar inicialmente la cámara
-    // y las coordenadas de la sala donde se realizará el desplazamiento de la cámara.
-    if(roomXML->triple_room_data().present())
-    {
-      if(roomXML->triple_room_data().get().northeast().present())
-      {
-        rxml::northeast d = roomXML->triple_room_data().get().northeast().get();
-        room->addTripleRoomStartPoint(Northeast, d.x(), d.y());
-      }
-      if(roomXML->triple_room_data().get().southeast().present())
+   // Procesa el archivo XML especificado para construir la sala.
+   try
+   {
+      boost::property_tree::ptree xmlTree;
+      boost::property_tree::xml_parser::read_xml(fileName, xmlTree);
+
+      std::map<std::string, FloorId> floorMap{{"none", NoFloor},
+                                              {"regular", RegularFloor},
+                                              {"mortal", MortalFloor}};
+
+      // Crea la sala con los parámetros básicos: identificador, dimensiones y existencia o no de suelo.
+      this->room = new Room(xmlTree.get<std::string>("room.name"),
+                            xmlTree.get<std::string>("room.scenery"),
+                            xmlTree.get<int>("room.xTiles"),
+                            xmlTree.get<int>("room.yTiles"),
+                            xmlTree.get<int>("room.width"),
+                            floorMap[xmlTree.get<std::string>("room.floorType")]);
+
+      if (this->room == 0)
       {
-        rxml::southeast d = roomXML->triple_room_data().get().southeast().get();
-        room->addTripleRoomStartPoint(Southeast, d.x(), d.y());
+         throw "Room creation error: " + fileName + " has bad atributtes.";
       }
-      if(roomXML->triple_room_data().get().northwest().present())
-      {
-        rxml::northwest d = roomXML->triple_room_data().get().northwest().get();
-        room->addTripleRoomStartPoint(Northwest, d.x(), d.y());
-      }
-      if(roomXML->triple_room_data().get().southwest().present())
-      {
-        rxml::southwest d = roomXML->triple_room_data().get().southwest().get();
-        room->addTripleRoomStartPoint(Southwest, d.x(), d.y());
-      }
-      if(roomXML->triple_room_data().get().eastnorth().present())
+
+      // Para calcular las coordenadas de pantalla donde se situará el origen del espacio isométrico,
+      // se necesita saber si la sala tiene puerta al norte y/o al este.
+      bool hasNorthDoor = false;
+      bool hasEastDoor = false;
+
+      // Recorre la lista de elementos buscando las puertas.
+      auto&& itemIter = xmlTree.get_child("room.items").equal_range("item");
+      for (auto&& i = itemIter.first; i != itemIter.second; ++i)
       {
-        rxml::eastnorth d = roomXML->triple_room_data().get().eastnorth().get();
-        room->addTripleRoomStartPoint(Eastnorth, d.x(), d.y());
+         if (i->second.get<std::string>("type") == "door")
+         {
+            std::string direction{i->second.get<std::string>("direction")};
+            if (direction == "north" || direction == "northeast" || direction == "northwest")
+            {
+               hasNorthDoor = true;
+            }
+            else if (direction == "east" || direction == "eastnorth" || direction == "eastsouth")
+            {
+               hasEastDoor = true;
+            }
+         }
       }
-      if(roomXML->triple_room_data().get().eastsouth().present())
+
+      // Una vez que se sabe de la existencia o no de las puertas, se calculan las coordenadas.
+      room->calculateCoordinates(hasNorthDoor, hasEastDoor,
+                                 xmlTree.get<int>("room.deltaX", 0),
+                                 xmlTree.get<int>("room.deltaY", 0));
+
+      // Si la sala es triple se almacenan los datos constantes para situar inicialmente la cámara
+      // y las coordenadas de la sala donde se realizará el desplazamiento de la cámara.
+      auto&& rootNode = xmlTree.get_child("room");
+      if (rootNode.find("triple-room-data") != rootNode.not_found())
       {
-        rxml::eastsouth d = roomXML->triple_room_data().get().eastsouth().get();
-        room->addTripleRoomStartPoint(Eastsouth, d.x(), d.y());
+         auto&& tripleRoomNode = xmlTree.get_child("room.triple-room-data");
+
+         if (tripleRoomNode.find("northeast") != tripleRoomNode.not_found())
+         {
+            int x{tripleRoomNode.get<int>("northeast.x")};
+            int y{tripleRoomNode.get<int>("northeast.y")};
+            room->addTripleRoomStartPoint(Northeast, x, y);
+         }
+         if (tripleRoomNode.find("southeast") != tripleRoomNode.not_found())
+         {
+            int x{tripleRoomNode.get<int>("southeast.x")};
+            int y{tripleRoomNode.get<int>("southeast.y")};
+            room->addTripleRoomStartPoint(Southeast, x, y);
+         }
+         if (tripleRoomNode.find("northwest") != tripleRoomNode.not_found())
+         {
+            int x{tripleRoomNode.get<int>("northwest.x")};
+            int y{tripleRoomNode.get<int>("northwest.y")};
+            room->addTripleRoomStartPoint(Northwest, x, y);
+         }
+         if (tripleRoomNode.find("southwest") != tripleRoomNode.not_found())
+         {
+            int x{tripleRoomNode.get<int>("southwest.x")};
+            int y{tripleRoomNode.get<int>("southwest.y")};
+            room->addTripleRoomStartPoint(Southwest, x, y);
+         }
+         if (tripleRoomNode.find("eastnorth") != tripleRoomNode.not_found())
+         {
+            int x{tripleRoomNode.get<int>("eastnorth.x")};
+            int y{tripleRoomNode.get<int>("eastnorth.y")};
+            room->addTripleRoomStartPoint(Eastnorth, x, y);
+         }
+         if (tripleRoomNode.find("eastsouth") != tripleRoomNode.not_found())
+         {
+            int x{tripleRoomNode.get<int>("eastsouth.x")};
+            int y{tripleRoomNode.get<int>("eastsouth.y")};
+            room->addTripleRoomStartPoint(Eastsouth, x, y);
+         }
+         if (tripleRoomNode.find("westnorth") != tripleRoomNode.not_found())
+         {
+            int x{tripleRoomNode.get<int>("westnorth.x")};
+            int y{tripleRoomNode.get<int>("westnorth.y")};
+            room->addTripleRoomStartPoint(Westnorth, x, y);
+         }
+         if (tripleRoomNode.find("westsouth") != tripleRoomNode.not_found())
+         {
+            int x{tripleRoomNode.get<int>("westsouth.x")};
+            int y{tripleRoomNode.get<int>("westsouth.y")};
+            room->addTripleRoomStartPoint(Westsouth, x, y);
+         }
+
+         int xmin{tripleRoomNode.get<int>("bound-x.minimum")};
+         int xmax{tripleRoomNode.get<int>("bound-x.maximum")};
+         int ymin{tripleRoomNode.get<int>("bound-y.minimum")};
+         int ymax{tripleRoomNode.get<int>("bound-y.maximum")};
+         room->assignTripleRoomBounds(xmin, xmax, ymin, ymax);
       }
-      if(roomXML->triple_room_data().get().westnorth().present())
+
+      // Crea el suelo a base de losetas.
+      auto&& tileIter = xmlTree.get_child("room.floor").equal_range("tile");
+      for (auto&& i = tileIter.first; i != tileIter.second; ++i)
       {
-        rxml::westnorth d = roomXML->triple_room_data().get().westnorth().get();
-        room->addTripleRoomStartPoint(Westnorth, d.x(), d.y());
+         FloorTile* floorTile = this->buildFloorTile(i->second);
+         room->addComponent(floorTile);
       }
-      if(roomXML->triple_room_data().get().westsouth().present())
+
+      // Crea las paredes sin puertas.
+      if (rootNode.find("walls") != rootNode.not_found())
       {
-        rxml::westsouth d = roomXML->triple_room_data().get().westsouth().get();
-        room->addTripleRoomStartPoint(Westsouth, d.x(), d.y());
+         auto&& wallIter = xmlTree.get_child("room.walls").equal_range("wall");
+         for (auto&& i = wallIter.first; i != wallIter.second; ++i)
+         {
+            Wall* wall = this->buildWall(i->second);
+            room->addComponent(wall);
+         }
       }
 
-      room->assignTripleRoomBounds(roomXML->triple_room_data().get().bound_x().minimum(),
-                                   roomXML->triple_room_data().get().bound_x().maximum(),
-                                   roomXML->triple_room_data().get().bound_y().minimum(),
-                                   roomXML->triple_room_data().get().bound_y().maximum());
-    }
-
-    // Crea el suelo a base de losetas.
-    for(rxml::floor::tile_const_iterator i = roomXML->floor().tile().begin(); i != roomXML->floor().tile().end (); ++i)
-    {
-      FloorTile* floorTile = this->buildFloorTile(*i);
-      room->addComponent(floorTile);
-    }
-
-    // Crea las paredes sin puertas.
-    if(roomXML->walls().present())
-    {
-      for(rxml::walls::wall_const_iterator i = roomXML->walls().get().wall().begin(); i != roomXML->walls().get().wall().end(); ++i)
+      // Sitúa los elementos en la sala. Un elemento puede ser: un muro, una puerta, uno rejilla o uno libre.
+      auto&& itemIter2 = xmlTree.get_child("room.items").equal_range("item");
+      for (auto&& i = itemIter2.first; i != itemIter2.second; ++i)
       {
-        Wall* wall = this->buildWall(*i);
-        room->addComponent(wall);
+         std::string type{i->second.get<std::string>("type")};
+
+         // Es una puerta.
+         if (type == "door")
+         {
+            Door* door = this->buildDoor(i->second);
+
+            if (!door)
+            {
+               std::ostringstream oss;
+               oss << "Cannot build door with coordinates "
+                   << i->second.get<int>("<xmlattr>.x") << ", "
+                   << i->second.get<int>("<xmlattr>.y") << ", "
+                   << i->second.get<int>("<xmlattr>.z");
+               throw std::runtime_error{oss.str()};
+            }
+
+            room->addComponent(door);
+         }
+         // Es un elemento rejilla.
+         else if (type == "griditem")
+         {
+            GridItem* gridItem = this->buildGridItem(i->second);
+
+            if (gridItem == 0)
+            {
+               std::ostringstream oss;
+               oss << "Cannot build grid-item with coordinates "
+                   << i->second.get<int>("<xmlattr>.x") << ", "
+                   << i->second.get<int>("<xmlattr>.y") << ", "
+                   << i->second.get<int>("<xmlattr>.z");
+               throw std::runtime_error{oss.str()};
+            }
+
+            room->addComponent(gridItem);
+         }
+         // Es un elemento libre.
+         else if (type == "freeitem")
+         {
+            FreeItem* freeItem = this->buildFreeItem(i->second);
+
+            if (freeItem == 0)
+            {
+               // En este caso no se lanza ninguna excepción porque hay
+               // elementos -los bonus- que pueden no crearse.
+               std::ostringstream oss;
+               oss << "Cannot build free-item with coordinates "
+                   << i->second.get<int>("<xmlattr>.x") << ", "
+                   << i->second.get<int>("<xmlattr>.y") << ", "
+                   << i->second.get<int>("<xmlattr>.z");
+               std::cout << oss.str() << std::endl;
+            }
+            else
+            {
+               room->addComponent(freeItem);
+            }
+         }
       }
-    }
 
-    // Sitúa los elementos en la sala. Un elemento puede ser: un muro, una puerta, uno rejilla o uno libre.
-    for(rxml::items::item_const_iterator i = roomXML->items().item().begin(); i != roomXML->items().item().end (); ++i)
-    {
-      // Es una pared. Las paredes formadas por elementos son aquellas que tienen puertas.
-      if((*i).type() == rxml::type::wall)
-      {
+      // Calcula los límites de la sala.
+      room->calculateBounds();
+   }
+   catch (const std::runtime_error& e)
+   {
+      std::cerr << e.what() << std::endl;
+      throw e;
+   }
 
-      }
-      // Es una puerta.
-      else if((*i).type() == rxml::type::door)
-      {
-        Door* door = this->buildDoor(*i);
-
-        if(door == 0)
-        {
-          std::ostringstream oss;
-          oss << "Cannot build door with coordinates " << (*i).x() << ", " << (*i).y() << ", " << (*i).z();
-          throw oss.str();
-        }
-        room->addComponent(door);
-      }
-      // Es un elemento rejilla.
-      else if((*i).type() == rxml::type::griditem)
-      {
-        GridItem* gridItem = this->buildGridItem(*i);
-
-        if(gridItem == 0)
-        {
-          std::ostringstream oss;
-          oss << "Cannot build grid-item with coordinates " << (*i).x() << ", " << (*i).y() << ", " << (*i).z();
-          throw oss.str();
-        }
-        room->addComponent(gridItem);
-      }
-      // Es un elemento libre.
-      else if((*i).type() == rxml::type::freeitem)
-      {
-        FreeItem* freeItem = this->buildFreeItem(*i);
-
-        if(freeItem == 0)
-        {
-          // En este caso no se lanza ninguna excepción porque hay
-          // elementos -los bonus- que pueden no crearse.
-          std::ostringstream oss;
-          oss << "Cannot build free-item with coordinates " << (*i).x() << ", " << (*i).y() << ", " << (*i).z();
-          std::cout << oss.str() << std::endl;
-        }
-        else
-        {
-          room->addComponent(freeItem);
-        }
-      }
-    }
-
-    // Calcula los límites de la sala.
-    room->calculateBounds();
-  }
-  catch(const xml_schema::exception& e)
-  {
-    std::cout << e << std::endl;
-  }
-  catch(const Exception& e)
-  {
-    std::cout << e.what() << std::endl;
-  }
-
-  return this->room;
+   return this->room;
 }
 
-//--------------------------------------------------------------------------------------------------
-PlayerItem* RoomBuilder::buildPlayerItem(const PlayerId& playerId, const BehaviorId& behaviorId, int x, int y, int z, const Direction& direction)
+PlayerItem* RoomBuilder::buildPlayerItem(const PlayerId& playerId, const BehaviorId& behaviorId,
+                                         int x, int y, int z, const Direction& direction)
 {
-  return buildPlayerItem(this->room, playerId, behaviorId, x, y, z, direction);
+   return buildPlayerItem(this->room, playerId, behaviorId, x, y, z, direction);
 }
 
-//--------------------------------------------------------------------------------------------------
-PlayerItem* RoomBuilder::buildPlayerItem(Room* room, const PlayerId& playerId, const BehaviorId& behaviorId, int x, int y, int z, const Direction& direction, bool hasItem)
+PlayerItem* RoomBuilder::buildPlayerItem(Room* room, const PlayerId& playerId,
+                                         const BehaviorId& behaviorId, int x, int y, int z,
+                                         const Direction& direction, bool hasItem)
 {
-  PlayerItem* playerItem = 0;
-  GameManager* gameManager = GameManager::getInstance();
-  PlayerId newPlayerId = playerId;
-  BehaviorId newBehaviorId = behaviorId;
-
-  // Si el jugador compuesto se ha quedado sin vidas, se comprueba si alguno de
-  // los jugadores conseva alguna, para crearlo en su lugar.
-  if(gameManager->getLives(playerId) == 0)
-  {
-    if(playerId == HeadAndHeels)
-    {
-      // Jugador Superviviente.
-      if(gameManager->getLives(Head) > 0)
-      {
-        newPlayerId = Head;
-        newBehaviorId = HeadBehavior;
-      }
-      else if(gameManager->getLives(Heels) > 0)
+   PlayerItem* playerItem = 0;
+   GameManager* gameManager = GameManager::getInstance();
+   PlayerId newPlayerId = playerId;
+   BehaviorId newBehaviorId = behaviorId;
+
+   // Si el jugador compuesto se ha quedado sin vidas, se comprueba si alguno de
+   // los jugadores conseva alguna, para crearlo en su lugar.
+   if (gameManager->getLives(playerId) == 0)
+   {
+      if (playerId == HeadAndHeels)
       {
-        newPlayerId = Heels;
-        newBehaviorId = HeelsBehavior;
+         // Jugador Superviviente.
+         if (gameManager->getLives(Head) > 0)
+         {
+            newPlayerId = Head;
+            newBehaviorId = HeadBehavior;
+         }
+         else if (gameManager->getLives(Heels) > 0)
+         {
+            newPlayerId = Heels;
+            newBehaviorId = HeelsBehavior;
+         }
+         else
+         {
+            newPlayerId = NoPlayer;
+         }
       }
+      // Es posible que los dos jugadores se unieran en la sala y se hayan quedado sin vidas.
       else
       {
-        newPlayerId = NoPlayer;
-      }
-    }
-    // Es posible que los dos jugadores se unieran en la sala y se hayan quedado sin vidas.
-    else
-    {
-      if(gameManager->getLives(Head) == 0 && gameManager->getLives(Heels) == 0)
-      {
-        newPlayerId = NoPlayer;
+         if (gameManager->getLives(Head) == 0 && gameManager->getLives(Heels) == 0)
+         {
+            newPlayerId = NoPlayer;
+         }
       }
-    }
-  }
-
-  // Se buscan los datos del elemento.
-  ItemData* itemData = this->itemDataManager->find(short(newPlayerId));
-
-  // Si se han encontrado y al jugador le quedan vidas, se coloca el elemento en la sala.
-  if(newPlayerId != NoPlayer && itemData != 0)
-  {
-    // Para poder crear el jugador le deben quedar vidas.
-    if(gameManager->getLives(newPlayerId) > 0)
-    {
-      playerItem = new PlayerItem(itemData, x, y, z, direction);
-
-      // No se pueden llevar elementos a otras salas.
-      if(hasItem)
+   }
+
+   // Se buscan los datos del elemento.
+   ItemData* itemData = this->itemDataManager->find(short(newPlayerId));
+
+   // Si se han encontrado y al jugador le quedan vidas, se coloca el elemento en la sala.
+   if (newPlayerId != NoPlayer && itemData != 0)
+   {
+      // Para poder crear el jugador le deben quedar vidas.
+      if (gameManager->getLives(newPlayerId) > 0)
       {
-        gameManager->setItemTaken(0);
-      }
+         playerItem = new PlayerItem(itemData, x, y, z, direction);
 
-      // Asigna las vidas.
-      playerItem->setLives(gameManager->getLives(newPlayerId));
+         // No se pueden llevar elementos a otras salas.
+         if (hasItem)
+         {
+            gameManager->setItemTaken(0);
+         }
 
-      // Asigna la posesión de sus objetos.
-      playerItem->setTools(gameManager->hasTool(newPlayerId));
+         // Asigna las vidas.
+         playerItem->setLives(gameManager->getLives(newPlayerId));
 
-      // Asigna la cantidad de munición disponible.
-      playerItem->setAmmo(gameManager->getDonuts(newPlayerId));
+         // Asigna la posesión de sus objetos.
+         playerItem->setTools(gameManager->hasTool(newPlayerId));
 
-      // Asigna (si hay) la cantidad de grandes saltos disponibles.
-      playerItem->setHighJumps(gameManager->getHighJumps());
+         // Asigna la cantidad de munición disponible.
+         playerItem->setAmmo(gameManager->getDonuts(newPlayerId));
 
-      // Asigna (si hay) el tiempo restante de doble velocidad.
-      playerItem->setHighSpeed(gameManager->getHighSpeed());
+         // Asigna (si hay) la cantidad de grandes saltos disponibles.
+         playerItem->setHighJumps(gameManager->getHighJumps());
 
-      // Asigna (si hay) el tiempo restante de inmunidad.
-      playerItem->setShieldTime(gameManager->getShield(newPlayerId));
+         // Asigna (si hay) el tiempo restante de doble velocidad.
+         playerItem->setHighSpeed(gameManager->getHighSpeed());
 
-      // Un jugador necesita acceso a los datos de otros elementos dado que los
-      // necesita para modelar su comportamiento. Por ejemplo: el disparo y el elemento
-      // de transición entre los telepuertos.
-      playerItem->assignBehavior(newBehaviorId, reinterpret_cast<void*>(itemDataManager));
+         // Asigna (si hay) el tiempo restante de inmunidad.
+         playerItem->setShieldTime(gameManager->getShield(newPlayerId));
 
-      // Añade el jugador a la sala.
-      room->addComponent(playerItem);
-    }
-  }
+         // Un jugador necesita acceso a los datos de otros elementos dado que los
+         // necesita para modelar su comportamiento. Por ejemplo: el disparo y el elemento
+         // de transición entre los telepuertos.
+         playerItem->assignBehavior(newBehaviorId, reinterpret_cast<void*>(itemDataManager));
 
-  return playerItem;
-}
+         // Añade el jugador a la sala.
+         room->addComponent(playerItem);
+      }
+   }
 
-//--------------------------------------------------------------------------------------------------
-FloorTile* RoomBuilder::buildFloorTile(const rxml::tile& tile)
-{
-  FloorTile* floorTile = 0;
-
-  try
-  {
-    BITMAP* bitmap = load_bitmap((isomot::sharePath() + tile.bitmap()).c_str(), 0);
-    if(bitmap == 0) throw "Bitmap " + tile.bitmap() + " not found.";
-    int column = room->getTilesX() * tile.y() + tile.x();
-    floorTile = new FloorTile(column, tile.x(), tile.y(), bitmap);
-    floorTile->setOffset(tile.offsetX(), tile.offsetY());
-  }
-  catch(const Exception& e)
-  {
-    std::cout << e.what() << std::endl;
-  }
-
-  return floorTile;
+   return playerItem;
 }
 
-//--------------------------------------------------------------------------------------------------
-Wall* RoomBuilder::buildWall(const rxml::wall& wall)
+FloorTile* RoomBuilder::buildFloorTile(const boost::property_tree::ptree& tile)
 {
-  Wall* roomWall = 0;
-
-  try
-  {
-    BITMAP* bitmap = load_bitmap((isomot::sharePath() + wall.bitmap()).c_str(), 0);
-    if(bitmap == 0) throw "Bitmap " + wall.bitmap() + " not found.";
-    roomWall = new Wall(wall.axis() == rxml::axis::x ? AxisX : AxisY, wall.index(), bitmap);
-  }
-  catch(const Exception& e)
-  {
-    std::cout << e.what() << std::endl;
-  }
-
-  return roomWall;
+   FloorTile *floorTile = 0;
+
+   try
+   {
+      BITMAP *bitmap = load_bitmap((isomot::sharePath() + tile.get<std::string>("bitmap")).c_str(), 0);
+      if (bitmap == nullptr)
+      {
+         throw "Bitmap " + tile.get<std::string>("bitmap") + " not found.";
+      }
+      int column = room->getTilesX() * tile.get<int>("y") + tile.get<int>("x");
+      floorTile = new FloorTile(column, tile.get<int>("x"), tile.get<int>("y"), bitmap);
+      floorTile->setOffset(tile.get<int>("offsetX"), tile.get<int>("offsetY"));
+   }
+   catch (std::runtime_error& e)
+   {
+      std::cout << e.what() << std::endl;
+   }
+
+   return floorTile;
 }
 
-//--------------------------------------------------------------------------------------------------
-GridItem* RoomBuilder::buildGridItem(const rxml::item& item)
+Wall* RoomBuilder::buildWall(const boost::property_tree::ptree& wall)
 {
-  GridItem* gridItem = 0;
-
-  // Se buscan los datos del elemento.
-  ItemData* itemData = this->itemDataManager->find(item.label());
-
-  // Si se han encontrado, se coloca el elemento en la sala.
-  if(itemData != 0)
-  {
-    // Hay diferencia entre los enumerados de dirección manejados por el archivo y por las salas.
-    gridItem = new GridItem(itemData, item.x(), item.y(), (item.z() > Top ? item.z() * LayerHeight : Top),
-                            item.direction() == rxml::direction::none ? NoDirection : Direction(item.direction() - 1));
-
-    // Datos extra necesarios para el comportamiento del elemento.
-    if(item.behavior() == VolatileTimeBehavior || item.behavior() == VolatileTouchBehavior ||
-       item.behavior() == VolatileWeightBehavior || item.behavior() == VolatileHeavyBehavior ||
-       item.behavior() == VolatilePuppyBehavior)
-    {
-      gridItem->assignBehavior(BehaviorId(item.behavior()), reinterpret_cast<void*>(this->itemDataManager->find(BubblesLabel)));
-    }
-    else
-    {
-      gridItem->assignBehavior(BehaviorId(item.behavior()), 0);
-    }
-  }
-
-  return gridItem;
+   Wall* roomWall{};
+
+   try
+   {
+      BITMAP* bitmap = load_bitmap((isomot::sharePath() + wall.get<std::string>("bitmap")).c_str(), 0);
+      if (bitmap == nullptr)
+      {
+         throw "Bitmap " + wall.get<std::string>("bitmap") + " not found.";
+      }
+      roomWall = new Wall(wall.get<std::string>("axis") == "x" ? AxisX : AxisY,
+                          wall.get<int>("index"), bitmap);
+   }
+   catch (std::runtime_error& e)
+   {
+      std::cout << e.what() << std::endl;
+   }
+
+   return roomWall;
 }
 
-//--------------------------------------------------------------------------------------------------
-FreeItem* RoomBuilder::buildFreeItem(const rxml::item& item)
+GridItem* RoomBuilder::buildGridItem(const boost::property_tree::ptree& item)
 {
-  FreeItem* freeItem = 0;
-  int foundData = 0;
-  int* data = 0;
-
-  // Se buscan los datos del elemento.
-  ItemData* itemData = this->itemDataManager->find(item.label());
-
-  // Si se han encontrado, se coloca el elemento en la sala.
-  if(itemData != 0)
-  {
-    // Coordenadas libres.
-    int fx = item.x() * room->getTileSize() + ((room->getTileSize() - itemData->widthX) >> 1);
-    int fy = (item.y() + 1) * room->getTileSize() - ((room->getTileSize() - itemData->widthY) >> 1) - 1;
-    int fz = item.z() != Top ? item.z() * LayerHeight : Top;
-
-    // La única excepción para colocar un elemento es que sea un bonus y ya se haya cogido.
-    if(BonusManager::getInstance()->isPresent(room->getIdentifier(), itemData->label))
-    {
+   GridItem* gridItem{};
+
+   // Se buscan los datos del elemento.
+   ItemData* itemData = this->itemDataManager->find(item.get<short>("label"));
+
+   // Si se han encontrado, se coloca el elemento en la sala.
+   if (itemData != nullptr)
+   {
       // Hay diferencia entre los enumerados de dirección manejados por el archivo y por las salas.
-      freeItem = new FreeItem(itemData, fx, fy, fz,
-                              item.direction() == rxml::direction::none ? NoDirection : Direction(item.direction() - 1));
+      std::string direction{item.get<std::string>("direction")};
+      gridItem = new GridItem(itemData,
+                              item.get<int>("<xmlattr>.x"),
+                              item.get<int>("<xmlattr>.y"),
+                              item.get<int>("<xmlattr>.z") > Top ? item.get<int>("<xmlattr>.z") * LayerHeight : Top,
+                              direction == "none" ? NoDirection : Direction(directionMap[direction]));
 
       // Datos extra necesarios para el comportamiento del elemento.
-      switch(item.behavior())
+      int behavior{item.get<int>("behavior")};
+      if (behavior == VolatileTimeBehavior ||
+          behavior == VolatileTouchBehavior ||
+          behavior == VolatileWeightBehavior ||
+          behavior == VolatileHeavyBehavior ||
+          behavior == VolatilePuppyBehavior)
+      {
+         gridItem->assignBehavior(BehaviorId(behavior),
+                                  reinterpret_cast<void*>(this->itemDataManager->find(BubblesLabel)));
+      }
+      else
+      {
+         gridItem->assignBehavior(BehaviorId(behavior), 0);
+      }
+   }
+
+   return gridItem;
+}
+
+FreeItem* RoomBuilder::buildFreeItem(const boost::property_tree::ptree& item)
+{
+   FreeItem* freeItem{};
+   int foundData{};
+   int* data{};
+
+   // Se buscan los datos del elemento.
+   ItemData* itemData = this->itemDataManager->find(item.get<short>("label"));
+
+   // Si se han encontrado, se coloca el elemento en la sala.
+   if (itemData != nullptr)
+   {
+      // Coordenadas libres.
+      int fx = item.get<int>("<xmlattr>.x") * room->getTileSize() + ((room->getTileSize() - itemData->widthX) >> 1);
+      int fy = (item.get<int>("<xmlattr>.y") + 1) * room->getTileSize() - ((room->getTileSize() - itemData->widthY) >> 1) - 1;
+      int fz = item.get<int>("<xmlattr>.z") != Top ? item.get<int>("<xmlattr>.z") * LayerHeight : Top;
+
+      // La única excepción para colocar un elemento es que sea un bonus y ya se haya cogido.
+      if (BonusManager::getInstance()->isPresent(room->getIdentifier(), itemData->label))
       {
-        case ElevatorBehavior:
-          data = new int[3];
-
-          // Extrae los datos extra asociados al ascensor.
-          for(rxml::item::extra_const_iterator i = item.extra().begin(); i != item.extra().end (); ++i)
-          {
-            data[foundData++] = (*i);
-          }
-
-          // Si los tres datos necesarios constan entonces se asigna el comportamiento.
-          if(foundData == 3)
-          {
-            freeItem->assignBehavior(BehaviorId(item.behavior()), reinterpret_cast<void*>(data));
-            delete[] data;
-          }
-          break;
-
-        case HunterWaiting4Behavior:
-          freeItem->assignBehavior(BehaviorId(item.behavior()), reinterpret_cast<void*>(this->itemDataManager->find(ImperialGuardLabel)));
-          break;
-
-        case SpecialBehavior:
-        case VolatileTimeBehavior:
-        case VolatileTouchBehavior:
-        case VolatileWeightBehavior:
-        case CannonBallBehavior:
-          freeItem->assignBehavior(BehaviorId(item.behavior()), reinterpret_cast<void*>(this->itemDataManager->find(BubblesLabel)));
-          break;
-
-        default:
-          freeItem->assignBehavior(BehaviorId(item.behavior()), 0);
+         // Hay diferencia entre los enumerados de dirección manejados por el archivo y por las salas.
+         std::string direction{item.get<std::string>("direction")};
+         freeItem = new FreeItem(itemData, fx, fy, fz,
+                                 direction == "none" ? NoDirection : Direction(directionMap[direction]));
+
+         // Datos extra necesarios para el comportamiento del elemento.
+         switch (item.get<int>("behavior"))
+         {
+            case ElevatorBehavior:
+            {
+               data = new int[3];
+
+               // Extrae los datos extra asociados al ascensor.
+               auto&& extraIter = item.equal_range("extra");
+               for (auto&& i = extraIter.first; i != extraIter.second; ++i)
+               {
+                  data[foundData++] = boost::lexical_cast<int>(i->second.data());
+               }
+
+               // Si los tres datos necesarios constan entonces se asigna el comportamiento.
+               if (foundData == 3)
+               {
+                  freeItem->assignBehavior(BehaviorId(item.get<int>("behavior")),
+                                           reinterpret_cast<void*>(data));
+                  delete[] data;
+               }
+               break;
+            }
+
+            case HunterWaiting4Behavior:
+               freeItem->assignBehavior(BehaviorId(item.get<int>("behavior")),
+                                        reinterpret_cast<void*>(this->itemDataManager->find(ImperialGuardLabel)));
+               break;
+
+            case SpecialBehavior:
+            case VolatileTimeBehavior:
+            case VolatileTouchBehavior:
+            case VolatileWeightBehavior:
+            case CannonBallBehavior:
+               freeItem->assignBehavior(BehaviorId(item.get<int>("behavior")),
+                                        reinterpret_cast<void*>(this->itemDataManager->find(BubblesLabel)));
+               break;
+
+            default:
+               freeItem->assignBehavior(BehaviorId(item.get<int>("behavior")), 0);
+         }
       }
-    }
-  }
+   }
 
-  return freeItem;
+   return freeItem;
 }
 
-//--------------------------------------------------------------------------------------------------
-Door* RoomBuilder::buildDoor(const rxml::item& item)
+Door* RoomBuilder::buildDoor(const boost::property_tree::ptree& item)
 {
-  return new Door(this->itemDataManager, item.label(), item.x(), item.y(), (item.z() > Top ? item.z() * LayerHeight : Top), Direction(item.direction() - 1));
+   return new Door(this->itemDataManager,
+                   item.get<short>("label"),
+                   item.get<int>("<xmlattr>.x"),
+                   item.get<int>("<xmlattr>.y"),
+                   item.get<int>("<xmlattr>.z") > Top ? item.get<int>("<xmlattr>.z") * LayerHeight : Top,
+                   Direction(directionMap[item.get<std::string>("direction")]));
 }
 
 }
diff --git a/src/RoomBuilder.hpp b/src/RoomBuilder.hpp
index 7c546fb..f38fde2 100644
--- a/src/RoomBuilder.hpp
+++ b/src/RoomBuilder.hpp
@@ -22,11 +22,13 @@
 #ifndef ROOMBUILDER_HPP_
 #define ROOMBUILDER_HPP_
 
+#include <map>
 #include <string>
 #include <iostream>
 #include <sstream>
 #include <allegro.h>
-#include "csxml/RoomXML.hpp"
+#include <boost/property_tree/xml_parser.hpp>
+#include <boost/lexical_cast.hpp>
 #include "Ism.hpp"
 
 namespace isomot
@@ -48,104 +50,107 @@ class Door;
 class RoomBuilder
 {
 public:
-  
-  /**
-   * Constructor.
-   * @param itemDataManager Gestor de datos de los elementos del juego.
-   * @param fileName Nombre del archivo que contiene los datos de la sala.
-   */
-	RoomBuilder(ItemDataManager* itemDataManager, const std::string& fileName);
-	
-	/**
-   * Constructor para una sala que ya ha sido creada.
-   * @param itemDataManager Gestor de datos de los elementos del juego.
-   */
-  RoomBuilder(ItemDataManager* itemDataManager);
-	  
-	/**
-	 * Destructor.
-	 */
-	virtual ~RoomBuilder();
-	
-	/**
-	 * Construye la sala a partir de los datos del archivo XML.
-	 * @return Una sala ó 0 si la sala no se pudo construir.
-	 */
-	Room* buildRoom();
-	
-  /**
-   * Crea un jugador en la sala en construcción. La sala ya debe estar construida.
-   * @param playerId Identificador del jugador.
-   * @param behaviorId Comportamiento del jugador.
-   * @param x Coordenada isométrica X donde se situará al jugador.
-   * @param y Coordenada isométrica Y donde se situará al jugador.
-   * @param z Coordenada isométrica Z donde se situará al jugador.
-   * @param direction Dirección inicial del jugador.
-   */
-  PlayerItem* buildPlayerItem(const PlayerId& playerId, const BehaviorId& behaviorId, int x, int y, int z, const Direction& direction);
-	
-  /**
-   * Crea un jugador en la sala especificada. La sala ya debe estar construida.
-   * @param room La sala donde se creará el jugador.
-   * @param playerId Identificador del jugador. Puede cambiarse si se pretende crear al jugador compuesto
-   * cuando uno de los jugadores simples ya ha agotado sus vidas.
-   * @param behaviorId Comportamiento del jugador.
-   * @param x Coordenada isométrica X donde se situará al jugador.
-   * @param y Coordenada isométrica Y donde se situará al jugador.
-   * @param z Coordenada isométrica Z donde se situará al jugador.
-   * @param direction Dirección inicial del jugador.
-   * @param hasItem Indica si el jugador llevaba un elemento en el bolso.
-   */
-  PlayerItem* buildPlayerItem(Room* room, const PlayerId& playerId, const BehaviorId& behaviorId, int x, int y, int z, const Direction& direction, bool hasItem = false);
-  
+
+   /**
+    * Constructor.
+    * @param itemDataManager Gestor de datos de los elementos del juego.
+    * @param fileName Nombre del archivo que contiene los datos de la sala.
+    */
+   RoomBuilder(ItemDataManager* itemDataManager, const std::string& fileName);
+
+   /**
+    * Constructor para una sala que ya ha sido creada.
+    * @param itemDataManager Gestor de datos de los elementos del juego.
+    */
+   RoomBuilder(ItemDataManager* itemDataManager);
+
+   /**
+    * Construye la sala a partir de los datos del archivo XML.
+    * @return Una sala ó 0 si la sala no se pudo construir.
+    */
+   Room* buildRoom();
+
+   /**
+    * Crea un jugador en la sala en construcción. La sala ya debe estar construida.
+    * @param playerId Identificador del jugador.
+    * @param behaviorId Comportamiento del jugador.
+    * @param x Coordenada isométrica X donde se situará al jugador.
+    * @param y Coordenada isométrica Y donde se situará al jugador.
+    * @param z Coordenada isométrica Z donde se situará al jugador.
+    * @param direction Dirección inicial del jugador.
+    */
+   PlayerItem* buildPlayerItem(const PlayerId& playerId, const BehaviorId& behaviorId,
+                               int x, int y, int z, const Direction& direction);
+
+   /**
+    * Crea un jugador en la sala especificada. La sala ya debe estar construida.
+    * @param room La sala donde se creará el jugador.
+    * @param playerId Identificador del jugador. Puede cambiarse si se pretende crear al jugador compuesto
+    * cuando uno de los jugadores simples ya ha agotado sus vidas.
+    * @param behaviorId Comportamiento del jugador.
+    * @param x Coordenada isométrica X donde se situará al jugador.
+    * @param y Coordenada isométrica Y donde se situará al jugador.
+    * @param z Coordenada isométrica Z donde se situará al jugador.
+    * @param direction Dirección inicial del jugador.
+    * @param hasItem Indica si el jugador llevaba un elemento en el bolso.
+    */
+   PlayerItem* buildPlayerItem(Room* room, const PlayerId& playerId, const BehaviorId& behaviorId,
+                               int x, int y, int z, const Direction& direction,
+                               bool hasItem = false);
+
 private:
-  
-  /**
-   * Crea una loseta.
-   * @param Datos del archivo XML para crear la loseta en la sala.
-   */
-  FloorTile* buildFloorTile(const rxml::tile& tile);
-
-  /**
-   * Crea un segmento de muro.
-   * @param Datos del archivo XML para crear el segmento de muro en la sala.
-   */
-  Wall* buildWall(const rxml::wall& wall);
-  
-  /**
-   * Crea un elemento rejilla.
-   * @param Datos del archivo XML para crear el elemento rejilla en la sala.
-   */
-  GridItem* buildGridItem(const rxml::item& item);
-  
-  /**
-   * Crea un elemento libre.
-   * @param Datos del archivo XML para crear el elemento libre en la sala.
-   */
-  FreeItem* buildFreeItem(const rxml::item& item);
-  
-  /**
-   * Crea una puerta.
-   * @param Datos del archivo XML para crear la puerta en la sala.
-   */
-  Door* buildDoor(const rxml::item& item);
-  
+
+   /**
+    * Crea una loseta.
+    * @param Datos del archivo XML para crear la loseta en la sala.
+    */
+   FloorTile* buildFloorTile(const boost::property_tree::ptree& tile);
+
+   /**
+    * Crea un segmento de muro.
+    * @param Datos del archivo XML para crear el segmento de muro en la sala.
+    */
+   Wall* buildWall(const boost::property_tree::ptree& wall);
+
+   /**
+    * Crea un elemento rejilla.
+    * @param Datos del archivo XML para crear el elemento rejilla en la sala.
+    */
+   GridItem* buildGridItem(const boost::property_tree::ptree& item);
+
+   /**
+    * Crea un elemento libre.
+    * @param Datos del archivo XML para crear el elemento libre en la sala.
+    */
+   FreeItem* buildFreeItem(const boost::property_tree::ptree& item);
+
+   /**
+    * Crea una puerta.
+    * @param Datos del archivo XML para crear la puerta en la sala.
+    */
+   Door* buildDoor(const boost::property_tree::ptree& item);
+
 private:
-  
-  /**
-   * Nombre del archivo XML que contiene los datos de la sala.
-   */
-  std::string fileName;
-  
-  /**
-   * Gestor de los datos invariables de los elementos del juego.
-   */
-  ItemDataManager* itemDataManager;
-  
-  /**
-   * La sala en construcción.
-   */
-  Room* room;
+
+   /**
+    * Nombre del archivo XML que contiene los datos de la sala.
+    */
+   std::string fileName;
+
+   /**
+    * Gestor de los datos invariables de los elementos del juego.
+    */
+   ItemDataManager* itemDataManager;
+
+   /**
+    * La sala en construcción.
+    */
+   Room* room;
+
+   /**
+    * Relación entre las direcciones que figuran en los archivos XML y sus enumeradores.
+    */
+   std::map<std::string, Direction> directionMap;
 };
 
 }
diff --git a/src/SoundManager.cpp b/src/SoundManager.cpp
index 6a8711d..51db5e9 100644
--- a/src/SoundManager.cpp
+++ b/src/SoundManager.cpp
@@ -1,363 +1,343 @@
 #include "SoundManager.hpp"
-#include "Exception.hpp"
 
 using isomot::SoundManager;
 using isomot::SampleData;
 using isomot::SoundData;
-using isomot::Exception;
-using isomot::EqualSoundData;
 
-//--------------------------------------------------------------------------------------------------
 SoundManager* SoundManager::instance = 0;
 
-//--------------------------------------------------------------------------------------------------
 SoundManager::SoundManager()
-: fileName(std::string()),
-  oggPlayer(0),
-  oggStream(0),
-  isPlayingOgg(false),
-  fxVolume(80),
-  musicVolume(75)
+   :
+   oggPlayer{},
+   oggStream{},
+   isPlayingOgg{},
+   fxVolume{80},
+   musicVolume{75}
 {
-  alogg_init();
-  install_timer();
-
-  int soundSystems[] = { DIGI_AUTODETECT,
-                         DIGI_ALSA,
-                         DIGI_OSS,
-                         DIGI_ESD,
-                         DIGI_ARTS,
-                         DIGI_JACK,
-                         DIGI_NONE };
-  int result = -1;
-  int index = 0;
-
-  while(result == -1)
-  {
-    result = install_sound(soundSystems[index++], MIDI_NONE, NULL);
-  }
+   alogg_init();
+   install_timer();
+
+   int soundSystems[] = { DIGI_AUTODETECT,
+                          DIGI_ALSA,
+                          DIGI_OSS,
+                          DIGI_ESD,
+                          DIGI_ARTS,
+                          DIGI_JACK,
+                          DIGI_NONE };
+   int result{-1};
+   int index{};
+
+   while(result == -1)
+   {
+      result = install_sound(soundSystems[index++], MIDI_NONE, NULL);
+   }
 }
 
-//--------------------------------------------------------------------------------------------------
 SoundManager::~SoundManager()
 {
-  alogg_exit();
+   alogg_exit();
 }
 
-//--------------------------------------------------------------------------------------------------
 SoundManager* SoundManager::getInstance()
 {
-  if(instance == 0)
-  {
-    instance = new SoundManager();
-  }
+   if(instance == 0)
+   {
+      instance = new SoundManager();
+   }
 
-  return instance;
+   return instance;
 }
 
-//--------------------------------------------------------------------------------------------------
 void SoundManager::load(const std::string& fileName)
 {
-  // Carga el archivo XML especificado y almacena los datos XML en la lista.
-  try
-  {
-    std::auto_ptr<sxml::SoundsXML> soundsXML(sxml::sounds((isomot::sharePath() + fileName).c_str()));
+   // Carga el archivo XML especificado y almacena los datos XML en la lista.
+   try
+   {
+      boost::property_tree::ptree xmlTree;
+      boost::property_tree::xml_parser::read_xml(fileName, xmlTree);
+
+      auto&& itemIter = xmlTree.get_child("sounds").equal_range("item");
+      for (auto&& i = itemIter.first; i != itemIter.second; ++i)
+      {
+         SoundData soundData{i->second.get<short>("<xmlattr>.label")};
 
-    for(sxml::SoundsXML::item_const_iterator i = soundsXML->item().begin(); i != soundsXML->item().end(); ++i)
-    {
-      SoundData soundData((*i).label());
+         auto&& stateIter = i->second.equal_range("state");
+         for (auto&& j = stateIter.first; j != stateIter.second; ++j)
+         {
+            soundData.add(j->second.get<std::string>("<xmlattr>.id"),
+                          j->second.get<std::string>("file"));
+         }
 
-      for(sxml::item::state_const_iterator s = (*i).state().begin(); s != (*i).state().end(); ++s)
-      {
-        soundData.add((*s).id(), (*s).file());
+         this->soundData.push_back(soundData);
       }
-
-      this->soundData.push_back(soundData);
-    }
-  }
-  catch(const xml_schema::exception& e)
-  {
-    std::cerr << e << std::endl;
-  }
-  catch(const Exception& e)
-  {
-    std::cerr << e.what() << std::endl;
-  }
+   }
+   catch (const std::runtime_error& e)
+   {
+      std::cerr << e.what() << std::endl;
+   }
 }
 
-//--------------------------------------------------------------------------------------------------
 void SoundManager::play(short label, const StateId& stateId, bool loop)
 {
-  SampleData* sampleData = this->findSample(label, stateId);
-
-  if(sampleData != 0 && sampleData->voice == -1)
-  {
-    deallocate_voice(sampleData->voice);
-    sampleData->voice = allocate_voice(sampleData->sample);
-    voice_set_volume(sampleData->voice, (this->fxVolume * 255) / 100);
-    if(loop)
-    {
-      voice_set_playmode(sampleData->voice, PLAYMODE_LOOP);
-    }
-    voice_start(sampleData->voice);
-  }
-
-  // TODO Adecentar.
-  for(std::list<SoundData>::iterator i = soundData.begin(); i != soundData.end(); ++i)
-  {
-    for(__gnu_cxx::hash_map<std::string, SampleData>::iterator j = (*i).table.begin(); j != (*i).table.end(); ++j)
-    {
-      if(voice_get_position(j->second.voice) == -1)
+   SampleData* sampleData = this->findSample(label, stateId);
+
+   if(sampleData != 0 && sampleData->voice == -1)
+   {
+      deallocate_voice(sampleData->voice);
+      sampleData->voice = allocate_voice(sampleData->sample);
+      voice_set_volume(sampleData->voice, (this->fxVolume * 255) / 100);
+      if(loop)
       {
-        deallocate_voice(j->second.voice);
-        (&(j->second))->voice = -1;
+         voice_set_playmode(sampleData->voice, PLAYMODE_LOOP);
       }
-    }
-  }
+      voice_start(sampleData->voice);
+   }
+
+   // TODO Adecentar.
+   for(std::list<SoundData>::iterator i = soundData.begin(); i != soundData.end(); ++i)
+   {
+      for(__gnu_cxx::hash_map<std::string, SampleData>::iterator j = (*i).table.begin(); j != (*i).table.end(); ++j)
+      {
+         if(voice_get_position(j->second.voice) == -1)
+         {
+            deallocate_voice(j->second.voice);
+            (&(j->second))->voice = -1;
+         }
+      }
+   }
 }
 
-//--------------------------------------------------------------------------------------------------
 void SoundManager::stop(short label, const StateId& stateId)
 {
-  SampleData* sampleData = this->findSample(label, stateId);
+   SampleData* sampleData = this->findSample(label, stateId);
 
-  if(sampleData != 0)
-  {
-    stop_sample(sampleData->sample);
-  }
+   if(sampleData != 0)
+   {
+      stop_sample(sampleData->sample);
+   }
 }
 
 //--------------------------------------------------------------------------------------------------
 void SoundManager::stopAllSounds()
 {
-  // TODO Adecentar.
-  for(std::list<SoundData>::iterator i = soundData.begin(); i != soundData.end(); ++i)
-  {
-    for(__gnu_cxx::hash_map<std::string, SampleData>::iterator j = (*i).table.begin(); j != (*i).table.end(); ++j)
-    {
-      stop_sample(j->second.sample);
-      if(voice_get_position(j->second.voice) == -1)
+   // TODO Adecentar.
+   for(std::list<SoundData>::iterator i = soundData.begin(); i != soundData.end(); ++i)
+   {
+      for(__gnu_cxx::hash_map<std::string, SampleData>::iterator j = (*i).table.begin(); j != (*i).table.end(); ++j)
       {
-        deallocate_voice(j->second.voice);
-        (&(j->second))->voice = -1;
+         stop_sample(j->second.sample);
+         if(voice_get_position(j->second.voice) == -1)
+         {
+            deallocate_voice(j->second.voice);
+            (&(j->second))->voice = -1;
+         }
       }
-    }
-  }
+   }
 }
 
-//--------------------------------------------------------------------------------------------------
 void SoundManager::playOgg(const std::string& fileName)
 {
-  // Si hay un tema reproduciéndose, se ignora la acción. Se debe detener primero.
-  if(!this->isPlayingOgg)
-  {
-    // Se crea un buffer de 40 KB.
-    set_volume((this->musicVolume * 255) / 100, 0);
-    this->oggStream = alogg_start_streaming((isomot::sharePath() + fileName).c_str(), 40 * 1024);
-    this->oggPlayer =  alogg_create_thread(this->oggStream);
-    this->oggPlaying = fileName;
-    this->isPlayingOgg = true;
-  }
+   // Si hay un tema reproduciéndose, se ignora la acción. Se debe detener primero.
+   if(!this->isPlayingOgg)
+   {
+      // Se crea un buffer de 40 KB.
+      set_volume((this->musicVolume * 255) / 100, 0);
+      this->oggStream = alogg_start_streaming((isomot::sharePath() + fileName).c_str(), 40 * 1024);
+      this->oggPlayer =  alogg_create_thread(this->oggStream);
+      this->oggPlaying = fileName;
+      this->isPlayingOgg = true;
+   }
 }
 
-//--------------------------------------------------------------------------------------------------
 void SoundManager::stopOgg()
 {
-  if(this->oggPlayer != 0)
-  {
-    if(this->oggPlayer->stop != 1)
-    {
-      alogg_stop_thread(this->oggPlayer);
-      while(alogg_is_thread_alive(this->oggPlayer));
-      alogg_join_thread(this->oggPlayer);
-      alogg_destroy_thread(this->oggPlayer);
-    }
-    this->oggStream = 0;
-    this->oggPlayer = 0;
-    this->oggPlaying.clear();
-    this->isPlayingOgg = false;
-  }
+   if(this->oggPlayer != 0)
+   {
+      if(this->oggPlayer->stop != 1)
+      {
+         alogg_stop_thread(this->oggPlayer);
+         while(alogg_is_thread_alive(this->oggPlayer));
+         alogg_join_thread(this->oggPlayer);
+         alogg_destroy_thread(this->oggPlayer);
+      }
+      this->oggStream = 0;
+      this->oggPlayer = 0;
+      this->oggPlaying.clear();
+      this->isPlayingOgg = false;
+   }
 }
 
-//--------------------------------------------------------------------------------------------------
 void SoundManager::setMusicVolume(int volume)
 {
-  this->musicVolume = volume == 0 ? 1 : volume;
-  set_volume((this->musicVolume * 255) / 100, 0);
+   this->musicVolume = volume == 0 ? 1 : volume;
+   set_volume((this->musicVolume * 255) / 100, 0);
 }
 
-//--------------------------------------------------------------------------------------------------
 SampleData* SoundManager::findSample(short label, const StateId& stateId)
 {
-  std::list<SoundData>::iterator i = std::find_if(soundData.begin(), soundData.end(), std::bind2nd(EqualSoundData(), label));
+  auto i = std::find_if(soundData.begin(), soundData.end(),
+                        [label] (const SoundData& data) {
+                           return data.getLabel() == label;
+                        });
 
-  return i != soundData.end() ? (*i).find(this->translateState(stateId)) : 0;
+  return i != soundData.end() ? (*i).find(this->translateState(stateId)) : nullptr;
 }
 
-//--------------------------------------------------------------------------------------------------
 std::string SoundManager::translateState(const StateId& stateId)
 {
-  std::string state;
-
-  switch(stateId)
-  {
-    case StateWait:
-      state = "wait";
-      break;
-
-    case StatePush:
-      break;
-
-    case StateMove:
-    case StateMoveNorth:
-    case StateMoveSouth:
-    case StateMoveEast:
-    case StateMoveWest:
-    case StateMoveNortheast:
-    case StateMoveSoutheast:
-    case StateMoveSouthwest:
-    case StateMoveNorthwest:
-    case StateMoveUp:
-    case StateMoveDown:
-    case StateAutoMove:
-    case StateAutoMoveNorth:
-    case StateAutoMoveSouth:
-    case StateAutoMoveEast:
-    case StateAutoMoveWest:
-      state = "move";
-      break;
-
-    case StateBlink:
-      break;
-
-    case StateJump:
-    case StateRegularJump:
-    case StateHighJump:
-      state = "jump";
-      break;
-
-    case StateFall:
-    case StateGlide:
-      state = "fall";
-      break;
-
-    case StateTakeItem:
-    case StateTakeAndJump:
-      state = "take";
-      break;
-
-    case StateTakenItem:
-      break;
-
-    case StateDropItem:
-    case StateDropAndJump:
-      state = "drop";
-      break;
-
-    case StateDisplaceNorth:
-    case StateDisplaceSouth:
-    case StateDisplaceEast:
-    case StateDisplaceWest:
-    case StateDisplaceNortheast:
-    case StateDisplaceSoutheast:
-    case StateDisplaceSouthwest:
-    case StateDisplaceNorthwest:
-    case StateDisplaceUp:
-    case StateDisplaceDown:
-      state = "push";
-      break;
-
-    case StateStartWayOutTeletransport:
-    case StateWayOutTeletransport:
-      state = "teleport-out";
-      break;
-
-    case StateStartWayInTeletransport:
-    case StateWayInTeletransport:
-      state = "teleport-in";
-      break;
-
-    case StateForceDisplaceNorth:
-    case StateForceDisplaceSouth:
-    case StateForceDisplaceEast:
-    case StateForceDisplaceWest:
-      state = "force";
-      break;
-
-    case StateCancelDisplaceNorth:
-    case StateCancelDisplaceSouth:
-    case StateCancelDisplaceEast:
-    case StateCancelDisplaceWest:
-      state = "move";
-      break;
-
-    case StateStartDestroy:
-      break;
-
-    case StateDestroy:
-      state = "destroy";
-      break;
-
-    case StateShot:
-      state = "shot";
-      break;
-
-    case StateRebound:
-      state = "rebound";
-      break;
-
-    case StateSwitch:
-      state = "switch";
-      break;
-
-    case StateCollision:
-      state = "collision";
-      break;
-
-    case StateActive:
-      state = "active";
-      break;
-
-    case StateError:
-      state = "error";
-      break;
-
-    default:
-      ;
-  }
-
-  return state;
+   std::string state;
+
+   switch (stateId)
+   {
+      case StateWait:
+         state = "wait";
+         break;
+
+      case StatePush:
+         break;
+
+      case StateMove:
+      case StateMoveNorth:
+      case StateMoveSouth:
+      case StateMoveEast:
+      case StateMoveWest:
+      case StateMoveNortheast:
+      case StateMoveSoutheast:
+      case StateMoveSouthwest:
+      case StateMoveNorthwest:
+      case StateMoveUp:
+      case StateMoveDown:
+      case StateAutoMove:
+      case StateAutoMoveNorth:
+      case StateAutoMoveSouth:
+      case StateAutoMoveEast:
+      case StateAutoMoveWest:
+         state = "move";
+         break;
+
+      case StateBlink:
+         break;
+
+      case StateJump:
+      case StateRegularJump:
+      case StateHighJump:
+         state = "jump";
+         break;
+
+      case StateFall:
+      case StateGlide:
+         state = "fall";
+         break;
+
+      case StateTakeItem:
+      case StateTakeAndJump:
+         state = "take";
+         break;
+
+      case StateTakenItem:
+         break;
+
+      case StateDropItem:
+      case StateDropAndJump:
+         state = "drop";
+         break;
+
+      case StateDisplaceNorth:
+      case StateDisplaceSouth:
+      case StateDisplaceEast:
+      case StateDisplaceWest:
+      case StateDisplaceNortheast:
+      case StateDisplaceSoutheast:
+      case StateDisplaceSouthwest:
+      case StateDisplaceNorthwest:
+      case StateDisplaceUp:
+      case StateDisplaceDown:
+         state = "push";
+         break;
+
+      case StateStartWayOutTeletransport:
+      case StateWayOutTeletransport:
+         state = "teleport-out";
+         break;
+
+      case StateStartWayInTeletransport:
+      case StateWayInTeletransport:
+         state = "teleport-in";
+         break;
+
+      case StateForceDisplaceNorth:
+      case StateForceDisplaceSouth:
+      case StateForceDisplaceEast:
+      case StateForceDisplaceWest:
+         state = "force";
+         break;
+
+      case StateCancelDisplaceNorth:
+      case StateCancelDisplaceSouth:
+      case StateCancelDisplaceEast:
+      case StateCancelDisplaceWest:
+         state = "move";
+         break;
+
+      case StateStartDestroy:
+         break;
+
+      case StateDestroy:
+         state = "destroy";
+         break;
+
+      case StateShot:
+         state = "shot";
+         break;
+
+      case StateRebound:
+         state = "rebound";
+         break;
+
+      case StateSwitch:
+         state = "switch";
+         break;
+
+      case StateCollision:
+         state = "collision";
+         break;
+
+      case StateActive:
+         state = "active";
+         break;
+
+      case StateError:
+         state = "error";
+         break;
+
+      default:
+         ;
+   }
+
+   return state;
 }
 
-//--------------------------------------------------------------------------------------------------
 SoundData::SoundData(short label)
-: label(label)
+   :
+   label{label}
 {
-  this->path = isomot::sharePath();
+   this->path = isomot::sharePath();
 }
 
-//--------------------------------------------------------------------------------------------------
 void SoundData::add(const std::string& state, const std::string& sampleFileName)
 {
-  SAMPLE* sample = load_sample((this->path + sampleFileName).c_str());
-  assert(sample != 0);
+   SAMPLE* sample = load_sample((this->path + sampleFileName).c_str());
+   assert(sample != 0);
 
-  SampleData sampleData;
-  sampleData.sample = sample;
-  sampleData.voice = -1;
-  this->table[state] = sampleData;
+   SampleData sampleData;
+   sampleData.sample = sample;
+   sampleData.voice = -1;
+   this->table[state] = sampleData;
 }
 
-//--------------------------------------------------------------------------------------------------
 SampleData* SoundData::find(const std::string& state)
 {
-  __gnu_cxx::hash_map<std::string, SampleData>::iterator i = this->table.find(state);
-
-  return i != this->table.end() ? (&(i->second)) : 0;
-}
+   __gnu_cxx::hash_map<std::string, SampleData>::iterator i = this->table.find(state);
 
-//--------------------------------------------------------------------------------------------------
-bool EqualSoundData::operator()(const SoundData& soundData, short label) const
-{
-  return (soundData.getLabel() == label);
+   return i != this->table.end() ? (&(i->second)) : 0;
 }
diff --git a/src/SoundManager.hpp b/src/SoundManager.hpp
index 1212629..5670678 100644
--- a/src/SoundManager.hpp
+++ b/src/SoundManager.hpp
@@ -30,9 +30,9 @@
 #include <functional>
 #include <cassert>
 #include <allegro.h>
+#include <boost/property_tree/xml_parser.hpp>
 #include "alogg/aloggpth.h"
 #include "alogg/aloggint.h"
-#include "csxml/SoundsXML.hpp"
 #include "Ism.hpp"
 
 #define BLOCK_SIZE 40960
@@ -297,14 +297,6 @@ public: // Operaciones de consulta y actualización.
   short getLabel() const { return this->label; }
 };
 
-/**
- * Objeto-función usado como predicado en la búsqueda de los datos de un sonido del juego.
- */
-struct EqualSoundData : public std::binary_function<SoundData, short, bool>
-{
-  bool operator()(const SoundData& soundData, short label) const;
-};
-
 }
 
 #endif /*SOUNDMANAGER_HPP_*/
diff --git a/src/actions/CreateFileGameMenu.cpp b/src/actions/CreateFileGameMenu.cpp
index 426e2a1..969ba3a 100644
--- a/src/actions/CreateFileGameMenu.cpp
+++ b/src/actions/CreateFileGameMenu.cpp
@@ -144,19 +144,26 @@ void CreateFileGameMenu::execute()
 //--------------------------------------------------------------------------------------------------
 void CreateFileGameMenu::recoverFileInfo(const std::string& fileName, short* rooms, short* planets)
 {
-  try
-  {
-    std::auto_ptr<sgxml::SaveGameXML> saveGameXML(sgxml::savegame(fileName.c_str()));
-
-    *rooms = saveGameXML->exploredRooms().visited().size();
-    *planets = (saveGameXML->freeByblos() ? 1 : 0) +
-               (saveGameXML->freeEgyptus() ? 1 : 0) +
-               (saveGameXML->freePenitentiary() ? 1 : 0) +
-               (saveGameXML->freeSafari() ? 1 : 0) +
-               (saveGameXML->freeBlacktooth() ? 1 : 0);
-  }
-  catch(const xml_schema::exception& e)
-  {
-    std::cout << e << std::endl;
-  }
+   try
+   {
+      boost::property_tree::ptree xmlTree;
+      boost::property_tree::xml_parser::read_xml(fileName, xmlTree);
+
+      auto&& visitedIter = xmlTree.get_child("savegame.exploredRooms").equal_range("visited");
+      short visitedRooms{}; // TODO Quitar el bucle
+      for (auto&& i = visitedIter.first; i != visitedIter.second; ++i)
+      {
+         ++visitedRooms;
+      }
+      *rooms = visitedRooms;
+      *planets = (xmlTree.get<bool>("savegame.freeByblos") ? 1 : 0) +
+                 (xmlTree.get<bool>("savegame.freeEgyptus") ? 1 : 0) +
+                 (xmlTree.get<bool>("savegame.freePenitentiary") ? 1 : 0) +
+                 (xmlTree.get<bool>("savegame.freeSafari") ? 1 : 0) +
+                 (xmlTree.get<bool>("savegame.freeBlacktooth") ? 1 : 0);
+   }
+   catch (const std::runtime_error& e)
+   {
+      std::cerr << e.what() << std::endl;
+   }
 }
diff --git a/src/actions/CreateFileGameMenu.hpp b/src/actions/CreateFileGameMenu.hpp
index 3463a08..7e99a09 100644
--- a/src/actions/CreateFileGameMenu.hpp
+++ b/src/actions/CreateFileGameMenu.hpp
@@ -25,7 +25,7 @@
 #include <sstream>
 #include <allegro.h>
 #include "Action.hpp"
-#include "csxml/SaveGameXML.hpp"
+#include <boost/property_tree/xml_parser.hpp>
 
 namespace gui
 {
diff --git a/src/actions/CreateLanguageMenu.cpp b/src/actions/CreateLanguageMenu.cpp
index 881758e..9fa753e 100644
--- a/src/actions/CreateLanguageMenu.cpp
+++ b/src/actions/CreateLanguageMenu.cpp
@@ -1,4 +1,3 @@
-
 #include "CreateLanguageMenu.hpp"
 #include "Ism.hpp"
 #include "GuiManager.hpp"
@@ -16,102 +15,101 @@ using gui::LanguageManager;
 using gui::LanguageText;
 using gui::SelectLanguage;
 
-//--------------------------------------------------------------------------------------------------
 CreateLanguageMenu::CreateLanguageMenu(BITMAP* destination)
-: Action(),
-  destination(destination)
+   :
+   Action(),
+   destination(destination)
 {
-  // Lee los idiomas en los que está disponible el juego.
-  this->parse(isomot::sharePath() + "text/language.xml");
+   // Lee los idiomas en los que está disponible el juego.
+   this->parse(isomot::sharePath() + "text/language.xml");
 
-  // Lee el idioma establecido en la configuración.
-  ConfigurationManager configurationManager(isomot::homePath() + "configuration.xml");
-  configurationManager.read();
-  language = configurationManager.getLanguage();
+   // Lee el idioma establecido en la configuración.
+   ConfigurationManager configurationManager(isomot::homePath() + "configuration.xml");
+   configurationManager.read();
+   language = configurationManager.getLanguage();
 }
 
-//--------------------------------------------------------------------------------------------------
 CreateLanguageMenu::~CreateLanguageMenu()
 {
-  this->texts.clear();
+   this->texts.clear();
 }
 
-//--------------------------------------------------------------------------------------------------
 void CreateLanguageMenu::execute()
 {
-  Label* label = 0;
-  Screen* screen = new Screen(0, 0, this->destination);
-
-  // Imagen de fondo.
-  screen->setBackground(GuiManager::getInstance()->findImage("background"));
-
-  // Etiqueta fija: HEAD.
-  label = new Label(200, 24, "HEAD");
-  label->changeFont("big", "yellow");
-  screen->addWidget(label);
-  // Etiqueta fija: OVER.
-  label = new Label(280, 45, "OVER", "regular", "multicolor");
-  screen->addWidget(label);
-  // Etiqueta fija: HEELS.
-  label = new Label(360, 24, "HEELS");
-  label->changeFont("big", "yellow");
-  screen->addWidget(label);
-
-  // Icono: Head.
-  screen->addWidget(new Icon(66, 24, GuiManager::getInstance()->findImage("head")));
-  // Icono: Heels.
-  screen->addWidget(new Icon(518, 24, GuiManager::getInstance()->findImage("heels")));
-
-  // Presenta los idiomas disponibles.
-  Menu* menu = new Menu(40, 120, 300, 11);
-  for(std::list<LanguageText*>::iterator i = this->texts.begin(); i != this->texts.end(); ++i)
-  {
-    label = new Label((*i)->getText());
-    label->setAction(new SelectLanguage(this->destination, (*i)->getId()));
-    if((this->language.empty() && i == this->texts.begin()) || this->language.compare((*i)->getId()) == 0)
-    {
-      menu->addActiveOption(label);
-    }
-    else
-    {
-      menu->addOption(label);
-    }
-  }
-  screen->addWidget(menu);
+   Label *label = 0;
+   Screen *screen = new Screen(0, 0, this->destination);
+
+   // Imagen de fondo.
+   screen->setBackground(GuiManager::getInstance()->findImage("background"));
+
+   // Etiqueta fija: HEAD.
+   label = new Label(200, 24, "HEAD");
+   label->changeFont("big", "yellow");
+   screen->addWidget(label);
+   // Etiqueta fija: OVER.
+   label = new Label(280, 45, "OVER", "regular", "multicolor");
+   screen->addWidget(label);
+   // Etiqueta fija: HEELS.
+   label = new Label(360, 24, "HEELS");
+   label->changeFont("big", "yellow");
+   screen->addWidget(label);
+
+   // Icono: Head.
+   screen->addWidget(new Icon(66, 24, GuiManager::getInstance()->findImage("head")));
+   // Icono: Heels.
+   screen->addWidget(new Icon(518, 24, GuiManager::getInstance()->findImage("heels")));
+
+   // Presenta los idiomas disponibles.
+   Menu *menu = new Menu(40, 120, 300, 11);
+   for (std::list<LanguageText*>::iterator i = this->texts.begin(); i != this->texts.end(); ++i)
+   {
+      label = new Label((*i)->getText());
+      label->setAction(new SelectLanguage(this->destination, (*i)->getId()));
+      if ((this->language.empty() && i == this->texts.begin()) || this->language.compare((*i)->getId()) == 0)
+      {
+         menu->addActiveOption(label);
+      }
+      else
+      {
+         menu->addOption(label);
+      }
+   }
+   screen->addWidget(menu);
 
-  // Crea la cadena de responsabilidad.
-  screen->setSucessor(menu);
+   // Crea la cadena de responsabilidad.
+   screen->setSucessor(menu);
 
-  // Cambia la pantalla mostrada en la interfaz.
-  GuiManager::getInstance()->changeScreen(screen);
+   // Cambia la pantalla mostrada en la interfaz.
+   GuiManager::getInstance()->changeScreen(screen);
 }
 
-//--------------------------------------------------------------------------------------------------
 void CreateLanguageMenu::parse(const std::string& fileName)
 {
-  // Carga el archivo XML especificado y almacena los datos XML en la lista.
-  try
-  {
-    std::auto_ptr<lxml::LanguageXML> languageXML(lxml::language(fileName.c_str()));
+   // Carga el archivo XML especificado y almacena los datos XML en la lista.
+   try
+   {
+      boost::property_tree::ptree xmlTree;
+      boost::property_tree::xml_parser::read_xml(fileName, xmlTree);
+
+      // Almacena todos los registros del archivo en la lista.
+      auto&& textIter = xmlTree.get_child("language").equal_range("text");
+      for (auto&& i = textIter.first; i != textIter.second; ++i)
+      {
+         LanguageText* lang = new LanguageText(i->second.get<std::string>("<xmlattr>.id"),
+                                               i->second.get<unsigned int>("<xmlattr>.x"),
+                                               i->second.get<unsigned int>("<xmlattr>.y"));
 
-    // Almacena todos los registros del archivo en la lista.
-    for(lxml::LanguageXML::text_const_iterator t = languageXML->text().begin(); t != languageXML->text().end(); ++t)
-    {
-      LanguageText* lang = new LanguageText((*t).id(), (*t).x(), (*t).y());
+         auto&& propIter = i->second.equal_range("properties");
+         for (auto&& j = propIter.first; j != propIter.second; ++j)
+         {
+            lang->addLine(j->second.get<std::string>("ustring"), std::string(), std::string());
+         }
 
-      for(lxml::text::properties_const_iterator p = (*t).properties().begin(); p != (*t).properties().end(); ++p)
-      {
-        for(lxml::properties::ustring_const_iterator u = (*p).ustring().begin(); u != (*p).ustring().end(); ++u)
-        {
-          lang->addLine(*u, std::string(), std::string());
-        }
+         this->texts.push_back(lang);
       }
-
-      this->texts.push_back(lang);
-    }
-  }
-  catch(const xml_schema::exception& e)
-  {
-    std::cerr << e << std::endl;
-  }
+   }
+   catch (const std::runtime_error& e)
+   {
+      std::cerr << e.what() << std::endl;
+   }
 }
diff --git a/src/actions/CreateLanguageMenu.hpp b/src/actions/CreateLanguageMenu.hpp
index bc862e5..6d28c4c 100644
--- a/src/actions/CreateLanguageMenu.hpp
+++ b/src/actions/CreateLanguageMenu.hpp
@@ -25,9 +25,9 @@
 #include <string>
 #include <list>
 #include <functional>
+#include <boost/property_tree/xml_parser.hpp>
 #include <allegro.h>
 #include "Action.hpp"
-#include "csxml/LanguageXML.hpp"
 
 namespace gui
 {
@@ -42,47 +42,47 @@ class CreateLanguageMenu : public Action
 {
 public:
 
-  /**
-   * Constructor.
-   * @param destination Imagen donde se dibujará la interfaz gráfica.
-   */
-  CreateLanguageMenu(BITMAP* destination);
+   /**
+    * Constructor.
+    * @param destination Imagen donde se dibujará la interfaz gráfica.
+    */
+   CreateLanguageMenu(BITMAP* destination);
 
-  /**
-   * Destructor.
-   */
-  ~CreateLanguageMenu();
+   /**
+    * Destructor.
+    */
+   ~CreateLanguageMenu();
 
-  /**
-   * Ejecuta el contenido de la acción, es decir, muestra el menú de idioma.
-   */
-  void execute();
+   /**
+    * Ejecuta el contenido de la acción, es decir, muestra el menú de idioma.
+    */
+   void execute();
 
 private:
 
-  /**
-   * Analiza el archivo XML y extrae las cadenas ligándolas a un identificador textual.
-   * @param fileName Archivo XML con los textos empleados en el juego.
-   */
-  void parse(const std::string& fileName);
+   /**
+    * Analiza el archivo XML y extrae las cadenas ligándolas a un identificador textual.
+    * @param fileName Archivo XML con los textos empleados en el juego.
+    */
+   void parse(const std::string& fileName);
 
 private:
 
-  /**
-   * Idioma seleccinado en la configuración inicial.
-   */
-  std::string language;
-
-  /**
-   * Imagen donde se dibujará la interfaz gráfica.
-   */
-  BITMAP* destination;
-
-  /**
-   * Textos empleados en la interfaz de usuario. Cada elemento se compone de un identificador
-   * único, su posición en la pantalla y la cadena con el texto.
-   */
-  std::list<LanguageText*> texts;
+   /**
+    * Idioma seleccinado en la configuración inicial.
+    */
+   std::string language;
+
+   /**
+    * Imagen donde se dibujará la interfaz gráfica.
+    */
+   BITMAP* destination;
+
+   /**
+    * Textos empleados en la interfaz de usuario. Cada elemento se compone de un identificador
+    * único, su posición en la pantalla y la cadena con el texto.
+    */
+   std::list<LanguageText*> texts;
 };
 
 }
diff --git a/src/gui/ConfigurationManager.cpp b/src/gui/ConfigurationManager.cpp
index 0730448..9d782c7 100644
--- a/src/gui/ConfigurationManager.cpp
+++ b/src/gui/ConfigurationManager.cpp
@@ -1,80 +1,79 @@
 #include "ConfigurationManager.hpp"
 
+using namespace boost::property_tree;
 using gui::ConfigurationManager;
 using isomot::GameKey;
 
-//--------------------------------------------------------------------------------------------------
 ConfigurationManager::ConfigurationManager(const std::string& fileName)
-: fileName(fileName)
+   :
+   fileName{fileName}
 {
 
 }
 
-//--------------------------------------------------------------------------------------------------
 void ConfigurationManager::read()
 {
-  // Carga el archivo XML especificado y almacena los datos XML en los diferentes atributos.
-  try
-  {
-    std::auto_ptr<cxml::ConfigurationXML> configurationXML(cxml::configuration(fileName.c_str()));
-    
-    // Almacena el idioma seleccionado.
-    this->language = configurationXML->language();
-    
-    // Almacena la configuración del teclado.
-    this->keys[static_cast<int>(isomot::KeyNorth)] = configurationXML->keyboard().left();
-    this->keys[static_cast<int>(isomot::KeySouth)] = configurationXML->keyboard().right();
-    this->keys[static_cast<int>(isomot::KeyEast)] = configurationXML->keyboard().up();
-    this->keys[static_cast<int>(isomot::KeyWest)] = configurationXML->keyboard().down();
-    this->keys[static_cast<int>(isomot::KeyTake)] = configurationXML->keyboard().take();
-    this->keys[static_cast<int>(isomot::KeyJump)] = configurationXML->keyboard().jump();
-    this->keys[static_cast<int>(isomot::KeyShoot)] = configurationXML->keyboard().shoot();
-    this->keys[static_cast<int>(isomot::KeyTakeAndJump)] = configurationXML->keyboard().takeandjump();
-    this->keys[static_cast<int>(isomot::KeySwap)] = configurationXML->keyboard().swap();
-    this->keys[static_cast<int>(isomot::KeyHalt)] = configurationXML->keyboard().halt();
-    
-    // Almacena los niveles de volumen.
-    this->soundFxVolume = configurationXML->volume().fx();
-    this->musicVolume = configurationXML->volume().music();
-  }
-  catch(const xml_schema::exception& e)
-  {
-    std::cout << e << std::endl;
-  }
+   // Carga el archivo XML especificado y almacena los datos XML en los diferentes atributos.
+   try
+   {
+      ptree xmlTree;
+      xml_parser::read_xml(fileName, xmlTree);
+
+      // Almacena el idioma seleccionado.
+      this->language = xmlTree.get<std::string>("configuration.language");
+
+      // Almacena la configuración del teclado.
+      this->keys[static_cast<int>(isomot::KeyNorth)] = xmlTree.get<int>("configuration.keyboard.left");
+      this->keys[static_cast<int>(isomot::KeySouth)] = xmlTree.get<int>("configuration.keyboard.right");
+      this->keys[static_cast<int>(isomot::KeyEast)] = xmlTree.get<int>("configuration.keyboard.up");
+      this->keys[static_cast<int>(isomot::KeyWest)] = xmlTree.get<int>("configuration.keyboard.down");
+      this->keys[static_cast<int>(isomot::KeyTake)] = xmlTree.get<int>("configuration.keyboard.take");
+      this->keys[static_cast<int>(isomot::KeyJump)] = xmlTree.get<int>("configuration.keyboard.jump");
+      this->keys[static_cast<int>(isomot::KeyShoot)] = xmlTree.get<int>("configuration.keyboard.shoot");
+      this->keys[static_cast<int>(isomot::KeyTakeAndJump)] = xmlTree.get<int>("configuration.keyboard.takeandjump");
+      this->keys[static_cast<int>(isomot::KeySwap)] = xmlTree.get<int>("configuration.keyboard.swap");
+      this->keys[static_cast<int>(isomot::KeyHalt)] = xmlTree.get<int>("configuration.keyboard.halt");
+
+      // Almacena los niveles de volumen.
+      this->soundFxVolume = xmlTree.get<int>("configuration.volume.fx");
+      this->musicVolume = xmlTree.get<int>("configuration.volume.music");
+   }
+   catch (const std::runtime_error& e)
+   {
+      std::cerr << e.what() << std::endl;
+   }
 }
 
-//--------------------------------------------------------------------------------------------------
 void ConfigurationManager::write()
 {
-  try
-  {
-    cxml::keyboard userKeys(this->keys[static_cast<int>(isomot::KeyNorth)],
-                            this->keys[static_cast<int>(isomot::KeySouth)],
-                            this->keys[static_cast<int>(isomot::KeyEast)],
-                            this->keys[static_cast<int>(isomot::KeyWest)],
-                            this->keys[static_cast<int>(isomot::KeyTake)],
-                            this->keys[static_cast<int>(isomot::KeyJump)],
-                            this->keys[static_cast<int>(isomot::KeyShoot)],
-                            this->keys[static_cast<int>(isomot::KeyTakeAndJump)],
-                            this->keys[static_cast<int>(isomot::KeySwap)],
-                            this->keys[static_cast<int>(isomot::KeyHalt)]);
-    
-    cxml::volume userVolume(this->soundFxVolume, this->musicVolume);
-    
-    // Creación de la configuración.
-    cxml::ConfigurationXML configurationXML(this->language, userKeys, userVolume);
-    
-    // Información del esquema.
-    xml_schema::namespace_infomap map;
-    map[""].name = "";
-    map[""].schema = "configuration.xsd";
+   try
+   {
+      ptree xmlTree;
+
+      xmlTree.put("configuration.<xmlattr>.xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
+      xmlTree.put("configuration.<xmlattr>.xsi:noNamespaceSchemaLocation", "configuration.xsd");
+
+      xmlTree.put("configuration.language", this->language);
+
+      xmlTree.put("configuration.keyboard.left", this->keys[isomot::KeyNorth]);
+      xmlTree.put("configuration.keyboard.right", this->keys[isomot::KeySouth]);
+      xmlTree.put("configuration.keyboard.up", this->keys[isomot::KeyEast]);
+      xmlTree.put("configuration.keyboard.down", this->keys[isomot::KeyWest]);
+      xmlTree.put("configuration.keyboard.take", this->keys[isomot::KeyTake]);
+      xmlTree.put("configuration.keyboard.jump", this->keys[isomot::KeyJump]);
+      xmlTree.put("configuration.keyboard.shoot", this->keys[isomot::KeyShoot]);
+      xmlTree.put("configuration.keyboard.takeandjump", this->keys[isomot::KeyTakeAndJump]);
+      xmlTree.put("configuration.keyboard.swap", this->keys[isomot::KeySwap]);
+      xmlTree.put("configuration.keyboard.halt", this->keys[isomot::KeyHalt]);
+
+      xmlTree.put("configuration.volume.fx", this->soundFxVolume);
+      xmlTree.put("configuration.volume.music", this->musicVolume);
     
-    // Creación del archivo.
-    std::ofstream outputFile(fileName.c_str());
-    cxml::configuration(outputFile, configurationXML, map);
-  }
-  catch(const xml_schema::exception& e)
-  {
-    std::cout << e << std::endl;
-  }
+      auto settings = xml_parser::xml_writer_make_settings<ptree::key_type>(' ', 3);
+      xml_parser::write_xml(fileName, xmlTree, std::locale(), settings);
+   }
+   catch (const std::runtime_error& e)
+   {
+      std::cerr << e.what() << std::endl;
+   }
 }
diff --git a/src/gui/ConfigurationManager.hpp b/src/gui/ConfigurationManager.hpp
index b307f97..bfd2c0a 100644
--- a/src/gui/ConfigurationManager.hpp
+++ b/src/gui/ConfigurationManager.hpp
@@ -27,7 +27,7 @@
 #include <fstream>
 #include <ext/hash_map>
 #include <allegro.h>
-#include "csxml/ConfigurationXML.hpp"
+#include <boost/property_tree/xml_parser.hpp>
 #include "Ism.hpp"
 
 namespace gui
@@ -42,104 +42,104 @@ class ConfigurationManager
 {
 public:
 
-  /**
-   * Constructor.
-   * @param fileName Archivo XML con la configuración del juego.
-   */
-  ConfigurationManager(const std::string& fileName);
+   /**
+    * Constructor.
+    * @param fileName Archivo XML con la configuración del juego.
+    */
+   ConfigurationManager(const std::string& fileName);
 
-  /**
-   * Lee los datos de configuración y los almacena en los atributos para que
-   * posteriormente puedan leerlos otros objetos de la interfaz de usuario.
-   */
-  void read();
+   /**
+    * Lee los datos de configuración y los almacena en los atributos para que
+    * posteriormente puedan leerlos otros objetos de la interfaz de usuario.
+    */
+   void read();
 
-  /**
-   * Guarda los datos de configuración almacenados en los atributos que han
-   * podido modificar otros objetos de la interfaz de usuario.
-   */
-  void write();
+   /**
+    * Guarda los datos de configuración almacenados en los atributos que han
+    * podido modificar otros objetos de la interfaz de usuario.
+    */
+   void write();
 
 private:
 
-  /**
-   * Archivo XML con la configuración del juego.
-   */
-  std::string fileName;
+   /**
+    * Archivo XML con la configuración del juego.
+    */
+   std::string fileName;
 
-  /**
-   * Idioma empleado en la interfaz de usuario.
-   */
-  std::string language;
+   /**
+    * Idioma empleado en la interfaz de usuario.
+    */
+   std::string language;
 
-  /**
-   * Tabla con las teclas empleadas en el juego.
-   */
-  __gnu_cxx::hash_map<int, int> keys;
+   /**
+    * Tabla con las teclas empleadas en el juego.
+    */
+   __gnu_cxx::hash_map<int, int> keys;
 
-  /**
-   * Volumen de los efectos de sonido; rango 0-99.
-   */
-  int soundFxVolume;
+   /**
+    * Volumen de los efectos de sonido; rango 0-99.
+    */
+   int soundFxVolume;
 
-  /**
-   * Volumen de la música; rango 0-99.
-   */
-  int musicVolume;
+   /**
+    * Volumen de la música; rango 0-99.
+    */
+   int musicVolume;
 
 public: // Operaciones de consulta y actualización.
 
-  /**
-   * Asigna el idioma empleado en la interfaz de usuario.
-   * @param language una cadena de caracteres con el formato LLL_CC donde LLL es un código de
-   * idioma según la norma ISO 639-2 y CC es un código de país según la norma ISO 3166.
-   */
-  void setLanguage(const std::string& language) { this->language = language; }
-
-  /**
-   * Idioma empleado en la interfaz de usuario.
-   * @return Una cadena de caracteres con el formato LLL_CC donde LLL es un código de
-   * idioma según la norma ISO 639 y CC es un código de país según la norma ISO 3166.
-   */
-  std::string getLanguage() { return this->language; }
-
-  /**
-   * Asigna una tecla a una acción del juego.
-   * @param gameKey Una acción del juego.
-   * @param key Una tecla según la codificación de Allegro: KEY_LEFT, KEY_A, etc.
-   */
-  void setKey(const isomot::GameKey& gameKey, int keyCode) { this->keys[static_cast<int>(gameKey)] = keyCode; }
-
-  /**
-   * Tecla ligada a una acción del juego.
-   * @param gameKey Una acción del juego.
-   * @return Una tecla según la codificación de Allegro: KEY_LEFT, KEY_A, etc.
-   */
-  int getKey(const isomot::GameKey& gameKey) { return this->keys[static_cast<int>(gameKey)]; }
-
-  /**
-   * Asigna el volumen de los efectos de sonido.
-   * @param volume Un valor entre 0 y 99, ambos inclusive.
-   */
-  void setSoundFxVolume(int volume) { this->soundFxVolume = volume; }
-
-  /**
-   * Volumen de los efectos de sonido.
-   * @return Un valor entre 0 y 99, ambos inclusive.
-   */
-  int getSoundFxVolume() const { return this->soundFxVolume; }
-
-  /**
-   * Asigna el volumen de la música.
-   * @param volume Un valor entre 0 y 99, ambos inclusive.
-   */
-  void setMusicVolume(int volume) { this->musicVolume = volume; }
-
-  /**
-   * Volumen de la música.
-   * @return Un valor entre 0 y 99, ambos inclusive.
-   */
-  int getMusicVolume() { return this->musicVolume; }
+   /**
+    * Asigna el idioma empleado en la interfaz de usuario.
+    * @param language una cadena de caracteres con el formato LLL_CC donde LLL es un código de
+    * idioma según la norma ISO 639-2 y CC es un código de país según la norma ISO 3166.
+    */
+   void setLanguage(const std::string& language) { this->language = language; }
+
+   /**
+    * Idioma empleado en la interfaz de usuario.
+    * @return Una cadena de caracteres con el formato LLL_CC donde LLL es un código de
+    * idioma según la norma ISO 639 y CC es un código de país según la norma ISO 3166.
+    */
+   std::string getLanguage() { return this->language; }
+
+   /**
+    * Asigna una tecla a una acción del juego.
+    * @param gameKey Una acción del juego.
+    * @param key Una tecla según la codificación de Allegro: KEY_LEFT, KEY_A, etc.
+    */
+   void setKey(const isomot::GameKey& gameKey, int keyCode) { this->keys[static_cast<int>(gameKey)] = keyCode; }
+
+   /**
+    * Tecla ligada a una acción del juego.
+    * @param gameKey Una acción del juego.
+    * @return Una tecla según la codificación de Allegro: KEY_LEFT, KEY_A, etc.
+    */
+   int getKey(const isomot::GameKey& gameKey) { return this->keys[static_cast<int>(gameKey)]; }
+
+   /**
+    * Asigna el volumen de los efectos de sonido.
+    * @param volume Un valor entre 0 y 99, ambos inclusive.
+    */
+   void setSoundFxVolume(int volume) { this->soundFxVolume = volume; }
+
+   /**
+    * Volumen de los efectos de sonido.
+    * @return Un valor entre 0 y 99, ambos inclusive.
+    */
+   int getSoundFxVolume() const { return this->soundFxVolume; }
+
+   /**
+    * Asigna el volumen de la música.
+    * @param volume Un valor entre 0 y 99, ambos inclusive.
+    */
+   void setMusicVolume(int volume) { this->musicVolume = volume; }
+
+   /**
+    * Volumen de la música.
+    * @return Un valor entre 0 y 99, ambos inclusive.
+    */
+   int getMusicVolume() { return this->musicVolume; }
 };
 
 }
diff --git a/src/gui/GuiManager.cpp b/src/gui/GuiManager.cpp
index 093ecb0..7c59f6b 100644
--- a/src/gui/GuiManager.cpp
+++ b/src/gui/GuiManager.cpp
@@ -31,7 +31,7 @@ GuiManager::GuiManager()
   this->allegroSetup();
 
   // Título de la ventana.
-  set_window_title("Head over Heels v1.0.1");
+  set_window_title("Head over Heels");
 
   // Ruta absoluta a los datos.
   std::string path = isomot::sharePath();
@@ -166,7 +166,7 @@ GuiManager::GuiManager()
   }
 
   // Se inicializa el gestor de sonido cargando los sonidos.
-  SoundManager::getInstance()->load("sounds.xml");
+  SoundManager::getInstance()->load(isomot::sharePath() + "sounds.xml");
 
   // Se comunica al gestor de sonido los niveles del volumen.
   SoundManager::getInstance()->setFxVolume(configurationManager->getSoundFxVolume());
diff --git a/src/gui/LanguageManager.cpp b/src/gui/LanguageManager.cpp
index 60a8a83..bf1ba83 100644
--- a/src/gui/LanguageManager.cpp
+++ b/src/gui/LanguageManager.cpp
@@ -4,101 +4,88 @@
 namespace gui
 {
 
-//--------------------------------------------------------------------------------------------------
 LanguageManager::LanguageManager(const std::string& fileName)
 {
-  this->parse(fileName);
+   this->parse(fileName);
 }
 
-//--------------------------------------------------------------------------------------------------
 LanguageManager::~LanguageManager()
 {
-  std::for_each(texts.begin(), texts.end(), DeleteObject());
-  texts.clear();
+   std::for_each(texts.begin(), texts.end(), DeleteObject());
+   texts.clear();
 }
 
-//--------------------------------------------------------------------------------------------------
 LanguageText* LanguageManager::findLanguageString(const std::string& id)
 {
-  std::list<LanguageText*>::iterator i = std::find_if(texts.begin(), texts.end(), std::bind2nd(EqualLanguageString(), id));
-  return (i != texts.end() ? *i : 0);
+   std::list<LanguageText*>::iterator i = std::find_if(texts.begin(), texts.end(),
+                                                       [&id](const LanguageText* lang) {
+                                                          return lang->getId() == id;
+                                                       });
+   return i != texts.end() ? *i : nullptr;
 }
 
-//--------------------------------------------------------------------------------------------------
 void LanguageManager::parse(const std::string& fileName)
 { 
-  // Carga el archivo XML especificado y almacena los datos XML en la lista.
-  try
-  {
-    std::auto_ptr<lxml::LanguageXML> languageXML(lxml::language(fileName.c_str()));
+   // Carga el archivo XML especificado y almacena los datos XML en la lista.
+   try
+   {
+      boost::property_tree::ptree xmlTree;
+      boost::property_tree::xml_parser::read_xml(fileName, xmlTree);
     
-    // Almacena todos los registros del archivo en la lista.
-    for(lxml::LanguageXML::text_const_iterator t = languageXML->text().begin(); t != languageXML->text().end(); ++t)
-    {
-      LanguageText* lang = new LanguageText((*t).id(), (*t).x(), (*t).y());
-      
-      for(lxml::text::properties_const_iterator p = (*t).properties().begin(); p != (*t).properties().end(); ++p)
+      // Almacena todos los registros del archivo en la lista.
+      auto&& textIter = xmlTree.get_child("language").equal_range("text");
+      for (auto&& i = textIter.first; i != textIter.second; ++i)
       {
-        std::string font;
-        if((*p).font().present())
-        {
-          font = (*p).font().get();
-        }
+         std::string id{i->second.get<std::string>("<xmlattr>.id")};
+         unsigned int x{i->second.get<unsigned int>("<xmlattr>.x")};
+         unsigned int y{i->second.get<unsigned int>("<xmlattr>.y")};
 
-        std::string color;
-        if((*p).color().present())
-        {
-          color = (*p).color().get();
-        }
-        
-        for(lxml::properties::ustring_const_iterator u = (*p).ustring().begin(); u != (*p).ustring().end(); ++u)
-        {
-          lang->addLine(*u, font, color);
-        }
+         LanguageText* lang = new LanguageText(id, x, y);
+
+         auto&& propIter = i->second.equal_range("properties");
+         for (auto&& j = propIter.first; j != propIter.second; ++j)
+         {
+            std::string font{j->second.get<std::string>("<xmlattr>.font", "")};
+            std::string color{j->second.get<std::string>("<xmlattr>.color", "")};
+            std::string text{j->second.get_child("ustring").data()};
+
+            lang->addLine(text, font, color);
+         }
+
+         this->texts.push_back(lang);
       }
-      
-      this->texts.push_back(lang);
-    }
-  }
-  catch(const xml_schema::exception& e)
-  {
-    std::cerr << e << std::endl;
-  }
+   }
+   catch (const std::runtime_error& e)
+   {
+      std::cerr << e.what() << std::endl;
+   }
 }
 
-//--------------------------------------------------------------------------------------------------
 LanguageText::LanguageText(const std::string& id, unsigned int x, unsigned int y)
-: id(id),
-  x(x),
-  y(y)
+   :
+   id{id},
+   x{x},
+   y{y}
 {
 
 }
 
-//--------------------------------------------------------------------------------------------------
 void LanguageText::addLine(const std::string& text)
 {
-  LanguageLine line;
-  line.text = text;
-  line.font = std::string();
-  line.color = std::string();
-  lines.push_back(line);
+   LanguageLine line;
+   line.text = text;
+   line.font = std::string();
+   line.color = std::string();
+   lines.push_back(line);
 }
 
-//--------------------------------------------------------------------------------------------------
 void LanguageText::addLine(const std::string& text, const std::string& font, const std::string& color)
 {
-  LanguageLine line;
-  line.text = text;
-  line.font = font;
-  line.color = color;
-  lines.push_back(line);
-}
-
-//--------------------------------------------------------------------------------------------------
-inline bool EqualLanguageString::operator()(const LanguageText* lang, const std::string& id) const
-{
-  return (lang->getId().compare(id) == 0);
+   LanguageLine line;
+   line.text = text;
+   line.font = font;
+   line.color = color;
+   lines.push_back(line);
 }
 
 }
diff --git a/src/gui/LanguageManager.hpp b/src/gui/LanguageManager.hpp
index c2e5520..191766d 100644
--- a/src/gui/LanguageManager.hpp
+++ b/src/gui/LanguageManager.hpp
@@ -28,7 +28,7 @@
 #include <algorithm>
 #include <functional>
 #include <iostream>
-#include "csxml/LanguageXML.hpp"
+#include <boost/property_tree/xml_parser.hpp>
 #include "Gui.hpp"
 
 namespace gui
@@ -44,105 +44,96 @@ class LanguageText;
 class LanguageManager
 {
 public:
-  
-  /**
-   * Constructor.
-   * @param fileName Archivo XML con los textos empleados en el juego.
-   */
-	LanguageManager(const std::string& fileName);
-	
-	/**
-	 * Destructor.
-	 */
-	~LanguageManager();
-	
-	/**
-	 * Busca una cadena de idioma.
-	 * @param id Cadena identificativa.
-	 * @return La cadena si se encontró ó 0 en caso contrario.
-	 */
-	LanguageText* findLanguageString(const std::string& id);
+
+   /**
+    * Constructor.
+    * @param fileName Archivo XML con los textos empleados en el juego.
+    */
+   LanguageManager(const std::string& fileName);
+
+   /**
+    * Destructor.
+    */
+   ~LanguageManager();
+
+   /**
+    * Busca una cadena de idioma.
+    * @param id Cadena identificativa.
+    * @return La cadena si se encontró ó 0 en caso contrario.
+    */
+   LanguageText* findLanguageString(const std::string& id);
 
 private:
-  
-  /**
-   * Analiza el archivo XML y extrae las cadenas ligándolas a un identificador textual.
-   * @param fileName Archivo XML con los textos empleados en el juego.
-   */
-  void parse(const std::string& fileName);
-  
+
+   /**
+    * Analiza el archivo XML y extrae las cadenas ligándolas a un identificador textual.
+    * @param fileName Archivo XML con los textos empleados en el juego.
+    */
+   void parse(const std::string& fileName);
+
 private:
   
-  /**
-   * Textos empleados en la interfaz de usuario. Cada elemento se compone de un identificador
-   * único, su posición en la pantalla y la cadena con el texto.
-   */
-  std::list<LanguageText*> texts;
-  
+   /**
+    * Textos empleados en la interfaz de usuario. Cada elemento se compone de un identificador
+    * único, su posición en la pantalla y la cadena con el texto.
+    */
+   std::list<LanguageText*> texts;
 };
 
 struct LanguageLine
 {
-  std::string text;
+   std::string text;
     
-  std::string font;
-  
-  std::string color;  
+   std::string font;
+
+   std::string color;
 };
 
 class LanguageText
 {
 public:
   
-  LanguageText(const std::string& id, unsigned int x, unsigned int y);
+   LanguageText(const std::string& id, unsigned int x, unsigned int y);
 
 private:
   
-  std::string id;
-  
-  unsigned int x;
-  
-  unsigned int y;
-  
-  std::vector<LanguageLine> lines;
+   std::string id;
+
+   unsigned int x;
+
+   unsigned int y;
+
+   std::vector<LanguageLine> lines;
   
 public:
   
-  void addLine(const std::string& text);
-  
-  void addLine(const std::string& text, const std::string& font, const std::string& color);
-  
-  std::string getId() const { return this->id; }
-  
-  unsigned int getX() const { return this->x; }
-  
-  unsigned int getY() const { return this->y; }
-  
-  std::string getFirstLineText() const { return this->lines[0].text; }
-  
-  std::string getFirstLineFont() const { return this->lines[0].font; }
-  
-  std::string getFirstLineColor() const { return this->lines[0].color; }
-  
-  std::string getText() const { return this->getFirstLineText(); }
-  
-  std::string getFont() const { return this->getFirstLineFont(); }
-  
-  std::string getColor() const { return this->getFirstLineColor(); }
-  
-  LanguageLine* getFirstLine() { return &(this->lines[0]); }
-  
-  LanguageLine* getLine(size_t number) { return &(this->lines[number]); }
-  
-  size_t getLinesCount() { return this->lines.size(); }
-};
+   void addLine(const std::string& text);
 
-/**
- * Objeto-función usado como predicado en la búsqueda de una cadena de idioma.
- */
-struct EqualLanguageString : public std::binary_function<LanguageText*, std::string, bool>
-{
-  bool operator()(const LanguageText* lang, const std::string& id) const;
+   void addLine(const std::string& text, const std::string& font, const std::string& color);
+
+   std::string getId() const { return this->id; }
+
+   unsigned int getX() const { return this->x; }
+
+   unsigned int getY() const { return this->y; }
+
+   std::string getFirstLineText() const { return this->lines[0].text; }
+
+   std::string getFirstLineFont() const { return this->lines[0].font; }
+
+   std::string getFirstLineColor() const { return this->lines[0].color; }
+
+   std::string getText() const { return this->getFirstLineText(); }
+
+   std::string getFont() const { return this->getFirstLineFont(); }
+
+   std::string getColor() const { return this->getFirstLineColor(); }
+
+   LanguageLine* getFirstLine() { return &(this->lines[0]); }
+
+   LanguageLine* getLine(size_t number) { return &(this->lines[number]); }
+
+   size_t getLinesCount() { return this->lines.size(); }
 };
 
 }
diff --git a/src/main.cpp b/src/main.cpp
index 2947db6..76751d1 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -10,6 +10,7 @@ int main()
   timeBeginPeriod(1);
 #endif
   
+  srand(time(0));
   gui::GuiManager::getInstance()->start();
 
 #ifdef __WIN32
--
